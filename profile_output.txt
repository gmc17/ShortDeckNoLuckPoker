/Users/glen/cfr/shortdecknoluckupdate/include/best_response.h:
    1|       |#pragma once
    2|       |#include <iostream>
    3|       |#include <utility>
    4|       |#include <algorithm>
    5|       |#include <array>
    6|       |#include <limits>
    7|       |#include <unordered_map>
    8|       |
    9|       |#include "game_state.h"
   10|       |#include "ars_table.h"
   11|       |#include "cfr.h"
   12|       |#include "constants.h"
   13|       |#include "info_set.h"
   14|       |
   15|       |float calculate_exploitability(std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
   16|       |                               std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range,
   17|       |                               const std::array<uint8_t, 5> board_cards, 
   18|       |                               float pot);
   19|       |
   20|       |std::array<std::array<float, NUM_CARDS>, NUM_CARDS> update_reach_probabilities(GameState gs, int action, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities);
   21|       |std::array<std::array<float, NUM_CARDS>, NUM_CARDS> update_chance_reach_probabilities(GameState gs, int num, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities);
   22|       |
   23|       |void print_opponent_reach_probabilities(const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities);
   24|       |float br_traverse_tree(GameState gs, bool exploitative_player, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities);
   25|       |float expected_utility(GameState gs, bool exploitative_player, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities);
   26|       |
   27|       |
   28|       |
   29|       |float calculate_exploitability_fast(const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_reach_probabilities, 
   30|       |                                    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_reach_probabilities,
   31|       |                                    const std::array<uint8_t, 5> board_cards, 
   32|       |                                    float pot);
   33|       |
   34|       |std::array<std::array<float, NUM_CARDS>, NUM_CARDS> br_traverse_tree_fast(GameState& gs, bool exploitative_player, 
   35|       |                                                                          const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& strategy_reach_probabilities);
   36|       |
   37|       |std::array<std::array<float, NUM_CARDS>, NUM_CARDS> expected_utility_fast(GameState gs, bool exploitative_player, 
   38|       |                                                                          const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& strategy_reach_probabilities);
   39|       |
   40|  6.30M|inline double clip(double value) {
   41|  6.30M|    return std::max(0.0, std::min(value, 1.0));
   42|  6.30M|}

/Users/glen/cfr/shortdecknoluckupdate/include/cfr.h:
    1|       |#pragma once
    2|       |#include <iostream>
    3|       |#include <array>
    4|       |#include <map>
    5|       |#include <algorithm>
    6|       |#include <stdexcept>
    7|       |#include <string>
    8|       |#include <sstream>
    9|       |#include <fstream>
   10|       |#include <immintrin.h>
   11|       |
   12|       |#include "constants.h"
   13|       |#include "game_state.h"
   14|       |#include "info_set.h"
   15|       |#include "best_response.h"
   16|       |#include "thread_pool.h"
   17|       |
   18|       |extern std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE> regret_sum;
   19|       |extern std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE> strategy_sum;
   20|       |
   21|       |void load_cfr_data(const std::string& filename,
   22|       |                   std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& regret_sum,
   23|       |                   std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& strategy_sum);
   24|       |
   25|       |void save_cfr_data(const std::string& filename,
   26|       |                   const std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& regret_sum,
   27|       |                   const std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& strategy_sum);
   28|       |
   29|       |std::array<float, 7> get_strategy(const InfoSet& info_set);
   30|       |std::array<float, 7> get_average_strategy(const InfoSet& info_set);
   31|       |
   32|       |int sample_action(const std::array<float, 7>& strategy);
   33|       |
   34|       |void as_mccfr(int iterations, std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
   35|       |                              std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
   36|       |                              std::array<uint8_t, 5> board_cards, float pot_size);
   37|       |
   38|       |void as_mccfr_worker(int start, int end, std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
   39|       |                                         std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
   40|       |                                         std::array<uint8_t, 5> board_cards, float pot_size);
   41|       |
   42|       |float as_traverse_tree(GameState& gs, bool active_player, float q);
   43|       |
   44|       |void cfr_plus(int iterations, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
   45|       |                              const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
   46|       |                              std::array<uint8_t, 5> board_cards, float pot_size);
   47|       |
   48|       |void cfr_plus_worker(int start, int end, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
   49|       |                                         const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
   50|       |                                         std::array<uint8_t, 5> board_cards, float pot_size, int thread_id);
   51|       |
   52|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> dcfr_traverse_tree_fast(GameState& state, bool traversing_player, int iteration,
   53|       |                                                                                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
   54|       |                                                                                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
   55|       |                                                                                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range);
   56|       |
   57|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> cfr_plus_traverse_tree_fast(GameState& state, bool traversing_player, float weight,
   58|       |                                                                                                 const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
   59|       |                                                                                                 const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
   60|       |                                                                                                 const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range);
   61|       |
   62|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> lcfr_traverse_tree_fast(GameState& state, bool traversing_player, float weight,
   63|       |                                                                                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
   64|       |                                                                                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
   65|       |                                                                                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range);
   66|       |
   67|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> update_reach_probabilities_cfr_plus(GameState state, int action, 
   68|       |                                                                                                         const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities);
   69|       |
   70|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> update_chance_reach_probabilities_cfr_plus(const GameState& state, int num, 
   71|       |                                                                                                                const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities);
   72|       |
   73|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> expected_utility_fast_cfr_plus(const GameState& state, bool traversing_player, 
   74|       |                                                                                                    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> reach_probabilities,
   75|       |                                                                                                    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
   76|       |                                                                                                    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range);
   77|       |
   78|       |
   79|       |
   80|       |void cfr_plus_parallel(int iterations, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
   81|       |                              const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
   82|       |                              std::array<uint8_t, 5> board_cards, float pot_size);
   83|       |
   84|       |void cfr_plus_worker_parallel(int start, int end, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
   85|       |                                         const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
   86|       |                                         std::array<uint8_t, 5> board_cards, float pot_size);
   87|       |
   88|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> cfr_plus_traverse_tree_fast_parallel(
   89|       |    GameState& state, bool traversing_player, float weight,
   90|       |    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
   91|       |    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
   92|       |    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range,
   93|       |    ThreadPool& pool);
   94|       |
   95|     50|inline int get_cpu_cores() {
   96|     50|    int cores = std::thread::hardware_concurrency();
   97|     50|    return (cores > 0) ? cores : 1;  // Return at least 1 if detection fails
   98|     50|}
   99|       |
  100|       |void add_2d_arrays_simd(std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& a,
  101|       |                        const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& b,
  102|       |                        std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& result);
  103|       |
  104|       |void multiply_2d_arrays_simd(std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& a,
  105|       |                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& b,
  106|       |                             std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& result);
  107|       |
  108|       |void fast_initialize_arrays(std::array<float, NUM_CARDS>& row_reach_sums_equal,
  109|       |                            std::array<float, NUM_CARDS>& col_reach_sums_equal);

/Users/glen/cfr/shortdecknoluckupdate/include/constants.h:
    1|       |#pragma once
    2|       |#include <string>
    3|       |#include <array>
    4|       |#include <cstddef>
    5|       |#include <unordered_map>
    6|       |#include <chrono>
    7|       |#include <random>
    8|       |#include <stack>
    9|       |#include <sstream>
   10|  1.70k|#define FIXED_FLOAT(x) std::fixed << std::setprecision(2) << (x)
   11|       |
   12|      0|inline std::mt19937& get_random_generator() {
   13|      0|    static thread_local std::mt19937 gen(std::random_device{}());
   14|      0|    return gen;
   15|      0|}
   16|      0|inline std::uniform_real_distribution<float>& get_uniform_distribution() {
   17|      0|    static thread_local std::uniform_real_distribution<float> dis(0.0f, 1.0f);
   18|      0|    return dis;
   19|      0|}
   20|      0|inline std::uniform_int_distribution<> get_card_distribution() {
   21|      0|    static thread_local std::uniform_int_distribution<> dis(1, 36);
   22|      0|    return dis;
   23|      0|}
   24|      0|constexpr std::array<int, 36 * 36> generate_pocket_id_table() {
   25|      0|    std::array<int, 36 * 36> table{};
   26|      0|    for (int p1 = 0; p1 < 36; ++p1) {
   27|      0|        for (int p2 = 0; p2 < 36; ++p2) {
   28|      0|        	bool suited = ((p1/9)==(p2/9));
   29|      0|            table[p1 * 36 + p2] = (suited) ? std::max((p1%9)*9 + p2%9, (p2%9)*9 + p1%9)
   30|      0|                    					   : std::min((p1%9)*9 + p2%9, (p2%9)*9 + p1%9);
   31|      0|        }
   32|      0|    }
   33|      0|    return table;
   34|      0|}
   35|       |inline constexpr auto POCKET_ID_TABLE = generate_pocket_id_table();
   36|  3.47k|inline constexpr int pocket_id(int p1, int p2) noexcept {
   37|  3.47k|    return POCKET_ID_TABLE[(p1-1) * 36 + (p2-1)];
   38|  3.47k|}
   39|      0|constexpr auto create_ones_array() {
   40|      0|    std::array<std::array<float, 36>, 36> res = {};
   41|      0|    for (auto& row : res) {
   42|      0|        for (auto& elem : row) {
   43|      0|            elem = 1.0f;
   44|      0|        }
   45|      0|    }
   46|      0|    return res;
   47|      0|}
   48|       |
   49|       |//****************************** CFR Parameters ******************************//
   50|       |static const size_t STRATEGY_ARRAY_SIZE = 5000007;
   51|       |static const float EPSILON = 0.05f;
   52|       |static const float TAU = 1000;
   53|       |static const float BETA = 1000000;
   54|       |
   55|       |static const float DCFR_ALPHA = 1.5f;
   56|       |static const float DCFR_BETA = 0.0f;
   57|       |static const float DCFR_GAMMA = 2.0f;
   58|       |
   59|       |static const uint8_t FLOP_BUCKETS = 100;
   60|       |static const uint8_t TURN_BUCKETS = 100;
   61|       |static const uint8_t RIVR_BUCKETS = 100;
   62|       |static const std::array<float, FLOP_BUCKETS> FLOP_BUCKETS_ARR = {0.212586f, 0.236864f, 0.251572f, 0.265294f, 0.276199f, 0.287481f, 0.295916f, 0.303057f, 0.308807f, 0.317067f, 0.324064f, 0.329401f, 0.335334f, 0.339599f, 0.343856f, 0.348642f, 0.35223f, 0.35735f, 0.361062f, 0.365889f, 0.370129f, 0.375378f, 0.378068f, 0.382191f, 0.385437f, 0.389338f, 0.393295f, 0.398017f, 0.402075f, 0.406405f, 0.409611f, 0.412195f, 0.414821f, 0.417412f, 0.421604f, 0.425537f, 0.428851f, 0.43166f, 0.435117f, 0.438867f, 0.441477f, 0.443548f, 0.447451f, 0.450983f, 0.454905f, 0.457864f, 0.460301f, 0.462896f, 0.465963f, 0.468883f, 0.471795f, 0.474216f, 0.477504f, 0.481153f, 0.484019f, 0.488389f, 0.492385f, 0.49641f, 0.500369f, 0.503798f, 0.508693f, 0.51303f, 0.518054f, 0.525526f, 0.532714f, 0.54161f, 0.547067f, 0.554007f, 0.562147f, 0.568448f, 0.574701f, 0.585489f, 0.593985f, 0.601386f, 0.606892f, 0.612711f, 0.618749f, 0.625165f, 0.633094f, 0.642679f, 0.647095f, 0.652945f, 0.662958f, 0.670666f, 0.675811f, 0.681646f, 0.689697f, 0.697487f, 0.708952f, 0.717659f, 0.73385f, 0.745911f, 0.76757f, 0.79292f, 0.820826f, 0.841296f, 0.861318f, 0.876335f, 0.89612f, 1.0f};
   63|       |static const std::array<float, TURN_BUCKETS> TURN_BUCKETS_ARR = {0.15792f, 0.181003f, 0.194257f, 0.211569f, 0.222222f, 0.230939f, 0.238199f, 0.245676f, 0.252257f, 0.258352f, 0.262909f, 0.268748f, 0.2743f, 0.279793f, 0.284725f, 0.289351f, 0.295454f, 0.300089f, 0.305063f, 0.30929f, 0.312945f, 0.319309f, 0.324026f, 0.328403f, 0.332377f, 0.336509f, 0.340345f, 0.344653f, 0.348964f, 0.353541f, 0.35736f, 0.362574f, 0.367175f, 0.371891f, 0.37583f, 0.380299f, 0.384952f, 0.389689f, 0.395024f, 0.400592f, 0.406025f, 0.410353f, 0.417159f, 0.423963f, 0.429535f, 0.436939f, 0.441231f, 0.447428f, 0.453016f, 0.458613f, 0.465429f, 0.474227f, 0.483467f, 0.490076f, 0.497443f, 0.50498f, 0.513411f, 0.522663f, 0.532198f, 0.541255f, 0.54766f, 0.552462f, 0.558618f, 0.568591f, 0.577642f, 0.584744f, 0.591177f, 0.600037f, 0.606827f, 0.615556f, 0.623263f, 0.629845f, 0.638078f, 0.64654f, 0.652692f, 0.661541f, 0.67396f, 0.68085f, 0.689577f, 0.697372f, 0.706259f, 0.714556f, 0.725507f, 0.741262f, 0.757957f, 0.768685f, 0.780041f, 0.793564f, 0.800697f, 0.816833f, 0.828207f, 0.838228f, 0.852835f, 0.862706f, 0.869278f, 0.886263f, 0.892009f, 0.946426f, 0.964123f, 1.0f};
   64|       |static const std::array<float, RIVR_BUCKETS> RIVR_BUCKETS_ARR = {0.0107905f, 0.0201254f, 0.0299482f, 0.0395268f, 0.0485912f, 0.0545718f, 0.0677025f, 0.0765087f, 0.0888627f, 0.0969953f, 0.106989f, 0.118112f, 0.130495f, 0.137547f, 0.150257f, 0.162407f, 0.173653f, 0.182596f, 0.190947f, 0.200835f, 0.210978f, 0.219748f, 0.225634f, 0.233613f, 0.243688f, 0.252463f, 0.2599f, 0.275133f, 0.294297f, 0.311714f, 0.326977f, 0.33757f, 0.347697f, 0.356147f, 0.363269f, 0.372073f, 0.382862f, 0.393029f, 0.4009f, 0.40907f, 0.415611f, 0.421848f, 0.431871f, 0.43986f, 0.44975f, 0.46054f, 0.471763f, 0.48081f, 0.4942f, 0.506483f, 0.513647f, 0.525564f, 0.53884f, 0.552616f, 0.56375f, 0.572733f, 0.580203f, 0.587843f, 0.603704f, 0.61399f, 0.621144f, 0.633477f, 0.64604f, 0.656881f, 0.665088f, 0.673133f, 0.681325f, 0.691016f, 0.699762f, 0.70702f, 0.716738f, 0.721527f, 0.731067f, 0.745019f, 0.756321f, 0.76648f, 0.772362f, 0.772366f, 0.79141f, 0.798767f, 0.798779f, 0.810884f, 0.816545f, 0.81938f, 0.825674f, 0.832786f, 0.838951f, 0.852901f, 0.856927f, 0.862471f, 0.868417f, 0.883682f, 0.889364f, 0.901519f, 0.945114f, 0.951334f, 0.960516f, 0.964913f, 0.974751f, 1.0f};
   65|       |
   66|       |//****************************** Utility Constants ******************************//
   67|       |static const int NUM_ROUNDS = 3;
   68|       |static const int NUM_RANKS = 9900;
   69|       |static const int NUM_POCKET_PAIRS = 81;
   70|       |static const int NUM_CARDS = 36;
   71|       |static const int MAX_ACTIONS = 7;
   72|       |static const uint32_t STACK_SIZE = 100;
   73|       |static const std::array<std::string,  4> SUIT_NAMES = {"♠", "♥", "♦", "♣"};
   74|       |static const std::array<std::string, 13> CARD_NAMES = {"6", "7", "8", "9", "T", "J", "Q", "K", "A"};
   75|       |static const std::array<int, 6> STRAIGHT_MASKS = {0b111110000, 0b011111000, 0b001111100, 0b000111110, 0b000011111, 0b100001111};
   76|       |static const std::array<int, 9> SINGLE_MASKS = {0b100000000, 0b010000000, 0b001000000, 0b000100000, 0b000010000, 0b000001000, 0b000000100, 0b000000010, 0b000000001};
   77|       |static const std::array<int, 9> OCTAL_MASKS = {0b111, 0b111000, 0b111000000, 0b111000000000, 0b111000000000000, 0b111000000000000000}; // currently allowing for only 3 bets per round
   78|       |static const std::unordered_map<std::string, int> STRING_TO_ACTION = {{"fold", 0}, {"check", 0}, {"call", 1}, {"bet", 1}, {"raise", 2}};
   79|       |static const std::array<float, 4> BET_SIZES = {0.5f, 0.75f, 1.0f, 2.0f};
   80|       |static const std::array<float, 4> RAISE_SIZES = {2.0f, 2.75f, 3.5f, 5.0f};
   81|       |static const std::array<std::string, 7> BET_ACTION_NAMES = {"Check", "Bet", "Bet", "Bet", "Bet", "All in", "Call"};
   82|       |static const std::array<std::string, 7> RAISE_ACTION_NAMES = {"Fold", "Raise", "Raise", "Raise", "Raise", "All in", "Call"};
   83|       |
   84|       |template<typename T>
   85|      7|std::string stack_to_string(std::stack<T> s) {
   86|      7|    std::stringstream ss;
   87|      7|    std::vector<T> temp;
   88|       |    
   89|     21|    while (!s.empty()) {
   90|     14|        temp.push_back(s.top());
   91|     14|        s.pop();
   92|     14|    }
   93|       |    
   94|     21|    for (int i=0; i<temp.size(); i++) {
   95|     14|        ss << temp[i];
   96|     14|        if (i != temp.size()-1) ss << ", ";
   97|     14|    }
   98|       |
   99|      7|    return ss.str();
  100|      7|};

/Users/glen/cfr/shortdecknoluckupdate/include/game_state.h:
    1|       |#pragma once
    2|       |#include <string>
    3|       |#include <functional>
    4|       |#include <iostream>
    5|       |#include <sstream>
    6|       |#include <vector>
    7|       |#include <stack>
    8|       |#include <array>
    9|       |#include <stdexcept>
   10|       |#include <initializer_list>
   11|       |#include <iostream>
   12|       |#include <bitset>
   13|       |#include <random>
   14|       |#include <cstdint>
   15|       |#include <unordered_map>
   16|       |
   17|       |#include "constants.h"
   18|       |#include "info_set.h"
   19|       |
   20|       |extern int dp[65536][4][8];
   21|       |extern int rank_table[8347680];
   22|       |
   23|       |class GameState {
   24|       |
   25|       |public:
   26|       |	/**
   27|       |	 * To be filled in
   28|       |	 * @param
   29|       |	*/
   30|       |
   31|       |	GameState();
   32|       |
   33|       |	// Utility methods
   34|       |	std::string to_string(bool verbose = false) const;
   35|       |	bool operator==(const GameState& other) const;
   36|       |
   37|       |	// Helpers
   38|   614M|	inline bool has_card(uint8_t card) const {
   39|   614M|		if ((card == op1) ||
   40|   627M|        (card == op2) ||
   41|   633M|        (card == ip1) ||
   42|   635M|        (card == ip2) ||
   43|   641M|        (card == fp1) ||
   44|   629M|        (card == fp2) ||
   45|   619M|        (card == fp3) ||
   46|   614M|        (card == trn) ||
   47|   614M|        (card == rvr))
   48|   156M|        	return true;
   49|   458M|    	return false;
   50|   614M|	}
   51|       |	int num_in_deck() const;
   52|       |
   53|       |	// Game logic
   54|       |	bool is_chance() const;
   55|       |	bool is_fold() const;
   56|       |	int best_hand(bool p) const;
   57|       |	int best_hand_fast(bool p) const;
   58|       |	float showdown(bool p) const;
   59|       |	float utility(bool p) const;
   60|       |	float utility_with_precomputed_hand_ranks(int p_hand_rank, int o_hand_rank) const;
   61|       |
   62|       |	int index_to_action(int index) const;
   63|       |	std::string action_to_string(int action) const;
   64|       |	std::string histories_to_string() const;
   65|       |	int action_to_index(int action) const;
   66|       |	int num_actions() const;
   67|       |	void apply_index(int index);
   68|       |	void deal_card(uint8_t card);
   69|       |	void undo(bool prev_player, float prev_pot);
   70|       |
   71|       |	// CFR helpers
   72|       |	InfoSet to_information_set() const;
   73|       |	float rivr_hand_strength();
   74|       |	int p_id(bool p) const;
   75|       |	void print_range(int index) const;
   76|       |	void print_range_turn(int index) const;
   77|       |	
   78|       |	bool player;
   79|       |	uint8_t op1;
   80|       |	uint8_t op2;
   81|       |	uint8_t ip1;
   82|       |	uint8_t ip2;
   83|       |	uint8_t fp1;
   84|       |	uint8_t fp2;
   85|       |	uint8_t fp3;
   86|       |	uint8_t trn;
   87|       |	uint8_t rvr;
   88|       |	uint32_t pfp_history;
   89|       |	uint32_t flp_history;
   90|       |	uint32_t trn_history;
   91|       |	uint32_t rvr_history;
   92|       |	bool flp_seen;
   93|       |	bool trn_seen;
   94|       |	bool rvr_seen;
   95|       |	bool is_terminal;
   96|       |	float pot_size;
   97|       |	std::stack<float> bets;
   98|       |};
   99|       |
  100|       |void play_computer();
  101|       |int ith_action(uint32_t history, int i);
  102|       |GameState generate_random_initial_state();
  103|       |std::array<int, 2> pocket_id_to_row_col(int id);
  104|   403M|inline int suit(uint8_t card) {
  105|   403M|	return (card-1)/9;
  106|   403M|}
  107|   401M|inline int rank(uint8_t card) {
  108|   401M|    return (card-1)%9;
  109|   401M|}
  110|       |
  111|       |int n_choose_k(int n, int k);
  112|       |int fast_hash(uint64_t handid, int k);
  113|       |void generate_dp_table();
  114|       |void generate_rank_table();
  115|       |void test_rank_table();

/Users/glen/cfr/shortdecknoluckupdate/include/thread_pool.h:
    1|       |#pragma once
    2|       |#include <vector>
    3|       |#include <queue>
    4|       |#include <thread>
    5|       |#include <mutex>
    6|       |#include <condition_variable>
    7|       |#include <functional>
    8|       |#include <future>
    9|       |#include <memory>
   10|       |#include <type_traits>
   11|       |
   12|       |class ThreadPool {
   13|       |public:
   14|     50|    ThreadPool(size_t num_threads) : stop(false) {
   15|    650|        for (size_t i = 0; i < num_threads; ++i) {
   16|    600|            workers.emplace_back([this] {
   17|  61.3k|                while (true) {
   18|  61.3k|                    std::function<void()> task;
   19|  61.3k|                    {
   20|  61.3k|                        std::unique_lock<std::mutex> lock(this->queue_mutex);
   21|  84.8k|                        this->condition.wait(lock, [this] { 
   22|  84.8k|                            return this->stop || !this->tasks.empty(); 
   23|  84.8k|                        });
   24|  61.3k|                        if (this->stop && this->tasks.empty()) {
   25|    600|                            return;
   26|    600|                        }
   27|  60.7k|                        task = std::move(this->tasks.front());
   28|  60.7k|                        this->tasks.pop();
   29|  60.7k|                    }
   30|      0|                    task();
   31|  60.7k|                }
   32|    592|            });
   33|    600|        }
   34|     50|    }
   35|       |
   36|       |    template<class F, class... Args>
   37|       |    auto enqueue(F&& f, Args&&... args) 
   38|  60.8k|    -> std::future<typename std::invoke_result<F, Args...>::type> {
   39|  60.8k|        using return_type = typename std::invoke_result<F, Args...>::type;
   40|       |
   41|  60.8k|        auto task = std::make_shared<std::packaged_task<return_type()>>(
   42|  60.8k|            std::bind(std::forward<F>(f), std::forward<Args>(args)...)
   43|  60.8k|        );
   44|       |            
   45|  60.8k|        std::future<return_type> res = task->get_future();
   46|  60.8k|        {
   47|  60.8k|            std::unique_lock<std::mutex> lock(queue_mutex);
   48|  60.8k|            if (stop) {
   49|      0|                throw std::runtime_error("enqueue on stopped ThreadPool");
   50|      0|            }
   51|  60.8k|            tasks.emplace([task](){ (*task)(); });
   52|  60.8k|        }
   53|      0|        condition.notify_one();
   54|  60.8k|        return res;
   55|  60.8k|    }
   56|       |
   57|     50|    ~ThreadPool() {
   58|     50|        {
   59|     50|            std::unique_lock<std::mutex> lock(queue_mutex);
   60|     50|            stop = true;
   61|     50|        }
   62|     50|        condition.notify_all();
   63|    600|        for (std::thread &worker: workers) {
   64|    600|            worker.join();
   65|    600|        }
   66|     50|    }
   67|       |
   68|       |private:
   69|       |    std::vector<std::thread> workers;
   70|       |    std::queue<std::function<void()>> tasks;
   71|       |    
   72|       |    std::mutex queue_mutex;
   73|       |    std::condition_variable condition;
   74|       |    bool stop;
   75|       |};

/Users/glen/cfr/shortdecknoluckupdate/include/tree.h:
    1|       |#pragma once
    2|       |#include <array>
    3|       |#include <vector>
    4|       |#include <variant>
    5|       |#include <memory>
    6|       |#include <cstdint>
    7|       |
    8|       |#include "constants.h"
    9|       |#include "game_state.h"
   10|       |#include "info_set.h"
   11|       |
   12|       |class Tree {
   13|       |public:
   14|       |	Tree(const GameState& root_state);
   15|      1|	~Tree() = default;
   16|       |
   17|       |private:
   18|       |	struct DecisionNode;
   19|       |	struct ChanceNode;
   20|       |	using Node = std::variant<DecisionNode, ChanceNode>;
   21|       |
   22|       |	struct DecisionNode {
   23|       |	    std::array<std::unique_ptr<Node>, MAX_ACTIONS> children;
   24|       |	    std::array<std::array<std::vector<float>, NUM_CARDS>, NUM_CARDS> strategy_sum;
   25|       |	    std::array<std::array<std::vector<float>, NUM_CARDS>, NUM_CARDS> regret_sum;
   26|       |
   27|       |	    explicit DecisionNode(int actions);
   28|       |	};
   29|       |
   30|       |	struct ChanceNode {
   31|       |	    std::array<std::unique_ptr<Node>, NUM_CARDS> children;
   32|       |	};
   33|       |
   34|       |	std::unique_ptr<Node> root;
   35|       |
   36|       |	void build_tree(Node* node, const GameState& state);
   37|       |	Node* get_node(const std::vector<int>& history) const;
   38|       |	std::array<std::array<std::vector<float>, NUM_CARDS>, NUM_CARDS> get_strategy_tree(const std::vector<int>& history) const;
   39|       |	std::array<std::array<std::vector<float>, NUM_CARDS>, NUM_CARDS> get_average_strategy_tree(const std::vector<int>& history) const;
   40|       |};
   41|       |
   42|       |int count_nodes(GameState state);

/Users/glen/cfr/shortdecknoluckupdate/src/best_response.cpp:
    1|       |#include "best_response.h"
    2|       |
    3|       |float calculate_exploitability(const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_reach_probabilities, 
    4|       |                               const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_reach_probabilities,
    5|       |                               const std::array<uint8_t, 5> board_cards, 
    6|      0|                               float pot) {
    7|       |
    8|      0|    try {
    9|      0|        load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
   10|      0|    } catch (const std::runtime_error& e) {
   11|      0|        std::cerr << "Error: " << e.what() << std::endl;
   12|      0|        return 0.0f;
   13|      0|    }
   14|       |
   15|      0|    std::array<float, 2> total_exploitability = {0.0f};
   16|       |
   17|      0|    GameState gs;
   18|      0|    gs.pfp_history = 0b111001;
   19|      0|    gs.flp_history = 0b1001;
   20|      0|    gs.pot_size = pot;
   21|      0|    gs.flp_seen = true;
   22|      0|    gs.trn_seen = true;
   23|      0|    gs.bets.push(0.0f);
   24|       |    
   25|      0|    gs.fp1 = board_cards[0];
   26|      0|    gs.fp2 = board_cards[1];
   27|      0|    gs.fp3 = board_cards[2];
   28|      0|    gs.trn = board_cards[3];
   29|      0|    gs.rvr = board_cards[4];
   30|       |
   31|      0|    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_info_set_utilities;
   32|      0|    for (int r=0; r<NUM_CARDS; r++) op_info_set_utilities[r] = {0.0f};
   33|       |
   34|      0|    for (int c1=1; c1<=NUM_CARDS; c1++) {
   35|      0|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
   36|       |            // Take out all private cards
   37|      0|            gs.ip1 = 0; gs.ip2 = 0; gs.op1 = 0; gs.op2 = 0;
   38|      0|            if (gs.has_card(c1) || gs.has_card(c2)) continue;
   39|       |
   40|      0|            for (int exploitative_player=0; exploitative_player<=1; exploitative_player++) {
   41|       |                // Skip hands that aren't part of our range
   42|      0|                if ((exploitative_player==0) && (op_reach_probabilities[c1-1][c2-1]<1e-6)) continue;
   43|      0|                if ((exploitative_player==1) && (ip_reach_probabilities[c1-1][c2-1]<1e-6)) continue;
   44|       |
   45|       |                // Assign our private cards
   46|      0|                if (exploitative_player==0) { gs.op1 = c1; gs.op2 = c2; gs.ip1 = 0; gs.ip2 = 0; }
   47|      0|                else { gs.ip1 = c1; gs.ip2 = c2; gs.op1 = 0; gs.op2 = 0; }
   48|       |
   49|      0|                total_exploitability[exploitative_player] += (exploitative_player == 0) ? op_reach_probabilities[c1-1][c2-1] * br_traverse_tree(gs, exploitative_player, ip_reach_probabilities)
   50|      0|                                                                                        : ip_reach_probabilities[c1-1][c2-1] * br_traverse_tree(gs, exploitative_player, op_reach_probabilities);
   51|       |
   52|      0|                op_info_set_utilities[c1-1][c2-1] = br_traverse_tree(gs, 0, ip_reach_probabilities);
   53|      0|                std::cout << "c1: " << c1 << "c2: " << c2 << "\n";
   54|      0|            }
   55|      0|        }
   56|      0|    }
   57|       |
   58|      0|    print_opponent_reach_probabilities(op_info_set_utilities);
   59|       |
   60|      0|    std::cout << "Avg exploitability (mbb/h) of OOP: " << 1000.0f * total_exploitability[1] / (pot * 0.5f) << "\n";
   61|      0|    std::cout << "Avg exploitability (mbb/h) of IP:  " << 1000.0f * total_exploitability[0] / (pot * 0.5f) << "\n";
   62|      0|    std::cout << "Avg exploitability (raw) of OOP:   " << total_exploitability[1] << "\n";
   63|      0|    std::cout << "Avg exploitability (raw) of IP:    " << total_exploitability[0] << "\n";
   64|       |    
   65|      0|    return (total_exploitability[0] + total_exploitability[1]) / 2;
   66|      0|}
   67|       |
   68|      0|float br_traverse_tree(GameState gs, bool exploitative_player, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
   69|       |
   70|      0|    if (gs.is_terminal) {
   71|      0|        return expected_utility(gs, exploitative_player, reach_probabilities);
   72|      0|    }
   73|       |
   74|      0|    float node_util = 0.0f;
   75|       |
   76|      0|    if (gs.is_chance()) {
   77|      0|        int num = gs.num_in_deck();
   78|       |
   79|      0|        for (int c=1; c<=NUM_CARDS; c++) {
   80|      0|            if (gs.has_card(c)) continue;
   81|       |
   82|      0|            GameState child = gs;
   83|      0|            child.deal_card(c);
   84|       |
   85|      0|            std::array<std::array<float, NUM_CARDS>, NUM_CARDS> new_reach_probabilities = update_chance_reach_probabilities(child, num, reach_probabilities);
   86|       |            
   87|      0|            node_util += br_traverse_tree(child, exploitative_player, new_reach_probabilities);
   88|      0|        }
   89|       |        
   90|      0|        return node_util;
   91|      0|    }
   92|       |
   93|      0|    int actions = gs.num_actions();
   94|       |
   95|      0|    if (gs.player != exploitative_player) {
   96|      0|        for (int a=0; a<actions; a++) {
   97|      0|            std::array<std::array<float, NUM_CARDS>, NUM_CARDS> new_reach_probabilities = update_reach_probabilities(gs, a, reach_probabilities);
   98|      0|            GameState child = gs;
   99|      0|            child.apply_index(a);
  100|      0|            node_util += br_traverse_tree(child, exploitative_player, new_reach_probabilities);
  101|      0|        }
  102|      0|        return node_util;
  103|      0|    }
  104|       |
  105|      0|    float action_val;
  106|      0|    float best_val = -9999.0f;
  107|       |    
  108|      0|    for (int a=0; a<actions; a++) {
  109|      0|        GameState child = gs;
  110|      0|        child.apply_index(a);
  111|      0|        action_val = br_traverse_tree(child, exploitative_player, reach_probabilities);
  112|       |
  113|      0|        best_val = std::max(best_val, action_val);
  114|      0|    }
  115|       |    
  116|      0|    return best_val;
  117|      0|}
  118|       |
  119|      0|float expected_utility(GameState gs, bool exploitative_player, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
  120|      0|    float expected_utility = 0.0f;
  121|       |
  122|      0|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  123|      0|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  124|      0|            if (exploitative_player==0) { gs.ip1 = 0; gs.ip2 = 0; }
  125|      0|            else { gs.op1 = 0; gs.op2 = 0; }
  126|       |
  127|      0|            if (gs.has_card(c1) || gs.has_card(c2)) continue;
  128|       |
  129|       |            // insert opponent's cards
  130|      0|            if (exploitative_player==0) { gs.ip1 = c1; gs.ip2 = c2; }
  131|      0|            else { gs.op1 = c1; gs.op2 = c2; }
  132|       |
  133|      0|            expected_utility += reach_probabilities[c1 - 1][c2 - 1] * gs.utility(exploitative_player);   
  134|      0|        }
  135|      0|    }
  136|       |
  137|      0|    return expected_utility;
  138|      0|}
  139|       |
  140|  3.89k|std::array<std::array<float, NUM_CARDS>, NUM_CARDS> update_reach_probabilities(GameState gs, int action, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
  141|  3.89k|    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> res;
  142|   144k|    for (int r=0; r<NUM_CARDS; r++) res[r].fill(0.0f);
  143|       |
  144|       |    // Mask out acting player's cards
  145|  3.89k|    if (gs.player==0) { gs.op1 = 0; gs.op2 = 0; }
  146|  1.94k|    else { gs.ip1 = 0; gs.ip2 = 0; }
  147|       |
  148|  3.89k|    InfoSet is = gs.to_information_set();
  149|       |
  150|   144k|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  151|  2.59M|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  152|  2.45M|            if (gs.has_card(c1) || gs.has_card(c2)) continue; // this combination of hole cards is not possible
  153|       |            
  154|       |            // Assign acting player their cards
  155|  1.81M|            is.cr1 = c1;
  156|  1.81M|            is.cr2 = c2;
  157|       |
  158|  1.81M|            float action_probability = get_average_strategy(is)[action];
  159|       |            
  160|  1.81M|            res[c1 - 1][c2 - 1] = (action_probability) * reach_probabilities[c1 - 1][c2 - 1];
  161|  1.81M|        }
  162|   140k|    }
  163|  3.89k|    return res;
  164|  3.89k|}
  165|       |
  166|  1.21k|std::array<std::array<float, NUM_CARDS>, NUM_CARDS> update_chance_reach_probabilities(GameState gs, int num, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
  167|  1.21k|    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> res;
  168|  44.9k|    for (int r=0; r<NUM_CARDS; r++) res[r].fill(0.0f);
  169|       |
  170|  44.9k|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  171|   809k|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  172|   766k|            if (gs.has_card(c1) || gs.has_card(c2)) continue; // this combination of hole cards is not possible
  173|       |            
  174|   565k|            res[c1 - 1][c2 - 1] = (1.0f / num) * reach_probabilities[c1 - 1][c2 - 1];
  175|   565k|        }
  176|  43.7k|    }
  177|  1.21k|    return res;
  178|  1.21k|}
  179|       |
  180|      0|void print_opponent_reach_probabilities(const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
  181|       |
  182|       |    // std::array<std::array<float, 9>, 9> p_id_reach_probabilities;
  183|       |
  184|       |    // for (int i=0; i<9; i++) {
  185|       |    //     p_id_reach_probabilities[i] = {0.0f};
  186|       |    // }
  187|       |
  188|       |    // std::cout << "Reach Probabilities:\n";
  189|       |    // for (int c1=1; c1<=NUM_CARDS; c1++) {
  190|       |    //     for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  191|       |    //         if (gs.has_card(c1) || gs.has_card(c2) || c1==c2) continue;
  192|       |    //         int p = pocket_id(c1, c2);
  193|       |    //         int r = pocket_id_to_row_col(p)[0];
  194|       |    //         int c = pocket_id_to_row_col(p)[1];
  195|       |
  196|       |    //         p_id_reach_probabilities[r][c] += reach_probabilities[c1 - 1][c2 - 1];
  197|       |    //     }
  198|       |    // }
  199|       |
  200|      0|    for (int c1=0; c1<=NUM_CARDS; c1++) {
  201|      0|        for (int c2=0; c2<=NUM_CARDS; c2++) {
  202|      0|            if (c1==0 && c2==0) {
  203|      0|                std::cout << "         ";
  204|      0|            } else if (c1==0 && c2>0) {
  205|      0|                std::cout << CARD_NAMES[(c2-1)%9] << "s        ";
  206|      0|            } else if (c2==0 && c1>0) {
  207|      0|                std::cout << CARD_NAMES[(c1-1)%9] << " ";
  208|      0|            } else {
  209|      0|                std::cout << std::scientific << std::setprecision(2);
  210|      0|                if (reach_probabilities[c1 - 1][c2 - 1] >= 0) std::cout << " ";
  211|      0|                std::cout << reach_probabilities[c1 - 1][c2 - 1] << " ";
  212|      0|            }
  213|      0|        }
  214|      0|        std::cout << "\n";
  215|      0|    }
  216|       |
  217|       |    // for (int r=0; r<10; r++) {
  218|       |    //     for (int c=0; c<10; c++) {
  219|       |    //         if (c==0 && r==0) {
  220|       |    //             std::cout << "         ";
  221|       |    //         } else if (r==0 && c>0) {
  222|       |    //             std::cout << CARD_NAMES[9-c] << "s        ";
  223|       |    //         } else if (c==0 && r>0) {
  224|       |    //             std::cout << CARD_NAMES[9-r] << " ";
  225|       |    //         } else {
  226|       |    //          // float f = 100.0f * range[r-1][c-1];
  227|       |    //             // std::cout << FIXED_FLOAT(f) << " ";
  228|       |    //             std::cout << std::scientific << std::setprecision(1);
  229|       |    //             std::cout << p_id_reach_probabilities[r - 1][c - 1] << " ";
  230|       |    //         }
  231|       |    //     }
  232|       |    //     std::cout << "\n";
  233|       |    // }
  234|      0|}
  235|       |
  236|       |float calculate_exploitability_fast(const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_reach_probabilities, 
  237|       |                                    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_reach_probabilities,
  238|       |                                    const std::array<uint8_t, 5> board_cards, 
  239|      1|                                    float pot) {
  240|       |
  241|      1|    try {
  242|      1|        load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
  243|      1|    } catch (const std::runtime_error& e) {
  244|      0|        std::cerr << "Error: " << e.what() << std::endl;
  245|      0|    }
  246|       |
  247|      1|    std::array<float, 2> total_exploitability; total_exploitability.fill(0.0f);
  248|       |
  249|      1|    GameState gs;
  250|      1|    gs.pfp_history = 0b111001;
  251|      1|    gs.flp_history = 0b1001;
  252|      1|    gs.pot_size = pot;
  253|      1|    gs.flp_seen = true;
  254|      1|    gs.trn_seen = true;
  255|      1|    gs.bets.push(0.0f);
  256|       |    
  257|      1|    gs.fp1 = board_cards[0];
  258|      1|    gs.fp2 = board_cards[1];
  259|      1|    gs.fp3 = board_cards[2];
  260|      1|    gs.trn = board_cards[3];
  261|      1|    gs.rvr = board_cards[4];
  262|       |
  263|      1|    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_info_set_utilities = br_traverse_tree_fast(gs, 0, ip_reach_probabilities);
  264|      1|    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_info_set_utilities = br_traverse_tree_fast(gs, 1, op_reach_probabilities);
  265|       |
  266|       |    // print_opponent_reach_probabilities(op_info_set_utilities);
  267|       |    // print_opponent_reach_probabilities(ip_info_set_utilities);
  268|       |
  269|     37|    for (int c1=1; c1<=NUM_CARDS; c1++) { 
  270|    666|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  271|    630|            if (gs.has_card(c1) || gs.has_card(c2)) continue;
  272|    496|            total_exploitability[0] += op_reach_probabilities[c1 - 1][c2 - 1] * op_info_set_utilities[c1 - 1][c2 - 1]; 
  273|    496|        }
  274|     36|    }
  275|       |
  276|     37|    for (int c1=1; c1<=NUM_CARDS; c1++) { 
  277|    666|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  278|    630|            if (gs.has_card(c1) || gs.has_card(c2)) continue;
  279|    496|            total_exploitability[1] += ip_reach_probabilities[c1 - 1][c2 - 1] * ip_info_set_utilities[c1 - 1][c2 - 1]; 
  280|    496|        }
  281|     36|    }
  282|       |    
  283|      1|    std::cout << "Exploitability of OOP: " << total_exploitability[1] << "\n";
  284|      1|    std::cout << "Exploitability of IP:  " << total_exploitability[0] << "\n";
  285|      1|    std::cout << "Total exploitability:  " << (total_exploitability[0] + total_exploitability[1]) / 2.0f << "\n";
  286|       |    
  287|      1|    return (total_exploitability[0] + total_exploitability[1]) / 2.0f;
  288|      1|}
  289|       |
  290|       |std::array<std::array<float, NUM_CARDS>, NUM_CARDS> br_traverse_tree_fast(GameState& gs, bool exploitative_player, 
  291|  9.01k|                                                                          const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& strategy_reach_probabilities) {
  292|  9.01k|    if (gs.is_terminal) {
  293|  5.60k|        return expected_utility_fast(gs, exploitative_player, strategy_reach_probabilities);
  294|  5.60k|    }
  295|       |
  296|  3.40k|    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> info_set_utilities;
  297|   126k|    for (int r=0; r<NUM_CARDS; r++) info_set_utilities[r].fill(0.0f);
  298|       |
  299|  3.40k|    if (gs.is_chance()) {
  300|     38|        int num = gs.num_in_deck();
  301|       |
  302|  1.40k|        for (int c=1; c<=NUM_CARDS; c++) {
  303|  1.36k|            if (gs.has_card(c)) continue;
  304|       |            
  305|  1.21k|            bool player_temp = gs.player; float pot_size_temp = gs.pot_size;
  306|  1.21k|            gs.deal_card(c);
  307|  1.21k|            std::array<std::array<float, NUM_CARDS>, NUM_CARDS> new_strategy_reach_probabilities = update_chance_reach_probabilities(gs, num, strategy_reach_probabilities);
  308|  1.21k|            std::array<std::array<float, NUM_CARDS>, NUM_CARDS> temp = br_traverse_tree_fast(gs, exploitative_player, new_strategy_reach_probabilities);
  309|  1.21k|            gs.undo(player_temp, pot_size_temp);
  310|       |
  311|  44.9k|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  312|   809k|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  313|   766k|                    if (gs.has_card(c1) || gs.has_card(c2) || (c1==c) || (c2==c)) continue;
  314|   565k|                    else info_set_utilities[c1 - 1][c2 - 1] += temp[c1 - 1][c2 - 1];
  315|   766k|                }
  316|  43.7k|            }
  317|  1.21k|        }
  318|     38|        return info_set_utilities;
  319|     38|    }
  320|       |
  321|  3.36k|    int actions = gs.num_actions();
  322|       |
  323|  3.36k|    if (gs.player != exploitative_player) {
  324|  5.58k|        for (int a=0; a<actions; a++) {
  325|  3.89k|            std::array<std::array<float, NUM_CARDS>, NUM_CARDS> new_strategy_reach_probabilities = update_reach_probabilities(gs, a, strategy_reach_probabilities);
  326|       |            
  327|  3.89k|            bool player_temp = gs.player; float pot_size_temp = gs.pot_size;
  328|  3.89k|            gs.apply_index(a);
  329|  3.89k|            std::array<std::array<float, NUM_CARDS>, NUM_CARDS> temp = br_traverse_tree_fast(gs, exploitative_player, new_strategy_reach_probabilities);
  330|  3.89k|            gs.undo(player_temp, pot_size_temp);
  331|       |
  332|   144k|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  333|  2.59M|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  334|  2.45M|                    if (gs.has_card(c1) || gs.has_card(c2)) info_set_utilities[c1 - 1][c2 - 1] = std::numeric_limits<float>::lowest();
  335|  1.81M|                    else info_set_utilities[c1 - 1][c2 - 1] += temp[c1 - 1][c2 - 1];
  336|  2.45M|                }
  337|   140k|            }
  338|  3.89k|        }
  339|  1.68k|        return info_set_utilities;
  340|  1.68k|    }
  341|       |
  342|  62.3k|    for (int r=0; r<NUM_CARDS; r++) info_set_utilities[r].fill(std::numeric_limits<float>::lowest());
  343|       |    
  344|  5.58k|    for (int a=0; a<actions; a++) {
  345|  3.89k|        bool player_temp = gs.player; float pot_size_temp = gs.pot_size;
  346|  3.89k|        gs.apply_index(a);
  347|  3.89k|        std::array<std::array<float, NUM_CARDS>, NUM_CARDS> temp = br_traverse_tree_fast(gs, exploitative_player, strategy_reach_probabilities);
  348|  3.89k|        gs.undo(player_temp, pot_size_temp);
  349|       |
  350|   144k|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  351|  2.59M|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  352|  2.45M|                if (gs.has_card(c1) || gs.has_card(c2)) info_set_utilities[c1 - 1][c2 - 1] = std::numeric_limits<float>::lowest();
  353|  1.81M|                else info_set_utilities[c1 - 1][c2 - 1] = std::max(info_set_utilities[c1 - 1][c2 - 1], temp[c1 - 1][c2 - 1]);
  354|  2.45M|            }
  355|   140k|        }
  356|  3.89k|    }
  357|       |    
  358|  1.68k|    return info_set_utilities;
  359|  3.36k|}
  360|       |
  361|       |std::array<std::array<float, NUM_CARDS>, NUM_CARDS> expected_utility_fast(GameState gs, bool exploitative_player, 
  362|  5.60k|                                                                          const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
  363|  5.60k|    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> expected_utilities;
  364|   207k|    for (int r=0; r<NUM_CARDS; r++) expected_utilities[r].fill(std::numeric_limits<float>::lowest());
  365|       |
  366|  5.60k|    std::array<float, NUM_CARDS> row_reach_sums; row_reach_sums.fill(0.0f);
  367|  5.60k|    std::array<float, NUM_CARDS> col_reach_sums; col_reach_sums.fill(0.0f);
  368|  5.60k|    float total_reach = 0.0f;
  369|       |
  370|   207k|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  371|  3.73M|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  372|  3.53M|            row_reach_sums[c1 - 1] += reach_probabilities[c1 - 1][c2 - 1];
  373|  3.53M|            col_reach_sums[c2 - 1] += reach_probabilities[c1 - 1][c2 - 1];
  374|  3.53M|            total_reach += reach_probabilities[c1 - 1][c2 - 1];
  375|  3.53M|        }
  376|   201k|    }
  377|       |
  378|  5.60k|    if (gs.is_fold()) {
  379|  2.21k|        float fold_utility = (gs.player == exploitative_player) ? gs.pot_size * -0.5f : gs.pot_size * 0.5f;
  380|  81.8k|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  381|  1.47M|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  382|  1.39M|                if (gs.has_card(c1) || gs.has_card(c2)) continue;
  383|  1.02M|                float r = total_reach - row_reach_sums[c1 - 1]
  384|  1.02M|                                      - col_reach_sums[c2 - 1]
  385|  1.02M|                                      + reach_probabilities[c1 - 1][c2 - 1];
  386|  1.02M|                expected_utilities[c1 - 1][c2 - 1] = fold_utility * r;
  387|  1.02M|            }
  388|  79.6k|        } 
  389|  2.21k|        return expected_utilities;
  390|  2.21k|    }
  391|       |
  392|  3.39k|    std::unordered_map<int, std::vector<std::tuple<float, int, int>>> strength_map;
  393|       |    
  394|       |    // Prepare all possible hands
  395|   125k|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  396|  2.25M|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  397|  2.13M|            if (gs.has_card(c1) || gs.has_card(c2)) continue;
  398|  1.57M|            GameState temp_gs = gs;
  399|  1.57M|            temp_gs.op1 = c1; temp_gs.op2 = c2;
  400|  1.57M|            int strength = temp_gs.best_hand(0);
  401|  1.57M|            float reach = reach_probabilities[c1 - 1][c2 - 1];
  402|       |
  403|  1.57M|            strength_map[strength].emplace_back(reach, c1, c2);
  404|  1.57M|        }
  405|   122k|    }
  406|       |
  407|  3.39k|    std::vector<int> sorted_strengths;
  408|  3.39k|    sorted_strengths.reserve(strength_map.size());
  409|       |
  410|   119k|    for (const auto& [strength, _] : strength_map) {
  411|   119k|        sorted_strengths.push_back(strength);
  412|   119k|    }
  413|       |
  414|  3.39k|    std::sort(sorted_strengths.begin(), sorted_strengths.end());
  415|       |
  416|  3.39k|    std::array<float, NUM_CARDS> row_reach_sums_worse; row_reach_sums_worse.fill(0.0f);
  417|  3.39k|    std::array<float, NUM_CARDS> col_reach_sums_worse; col_reach_sums_worse.fill(0.0f);
  418|  3.39k|    std::array<float, NUM_CARDS> row_reach_sums_equal; row_reach_sums_equal.fill(0.0f);
  419|  3.39k|    std::array<float, NUM_CARDS> col_reach_sums_equal; col_reach_sums_equal.fill(0.0f);
  420|       |
  421|  3.39k|    float cumulative_reach_probabilities_of_worse = 0.0f;
  422|  3.39k|    float cumulative_reach_probabilities_of_equal = 0.0f;
  423|       |    
  424|   119k|    for (int strength : sorted_strengths) {
  425|       |        // We've moved to a new hand rank level
  426|   119k|        cumulative_reach_probabilities_of_worse += cumulative_reach_probabilities_of_equal;
  427|   119k|        cumulative_reach_probabilities_of_equal = 0.0f;
  428|       |
  429|   119k|        row_reach_sums_equal.fill(0.0f);
  430|   119k|        col_reach_sums_equal.fill(0.0f);
  431|       |
  432|  1.57M|        for (const auto& [reach, c1, c2] : strength_map[strength]) {
  433|  1.57M|            cumulative_reach_probabilities_of_equal += reach;
  434|  1.57M|            row_reach_sums_equal[c1 - 1] += reach;
  435|  1.57M|            col_reach_sums_equal[c2 - 1] += reach;
  436|  1.57M|        }
  437|       |
  438|  1.57M|        for (const auto& [reach, c1, c2] : strength_map[strength]) {
  439|       |
  440|  1.57M|            float cumulative_reach_probabilities_of_hands_no_overlaps = clip(total_reach - row_reach_sums[c1 - 1] 
  441|  1.57M|                                                                                         - col_reach_sums[c2 - 1]
  442|  1.57M|                                                                                         + reach);
  443|       |            
  444|  1.57M|            float cumulative_reach_probabilities_of_worse_no_overlaps = clip(cumulative_reach_probabilities_of_worse - row_reach_sums_worse[c1 - 1]
  445|  1.57M|                                                                                                                     - col_reach_sums_worse[c2 - 1]);
  446|       |
  447|  1.57M|            float cumulative_reach_probabilities_of_equal_no_overlaps = clip(cumulative_reach_probabilities_of_equal - row_reach_sums_equal[c1 - 1]
  448|  1.57M|                                                                                                                     - col_reach_sums_equal[c2 - 1]
  449|  1.57M|                                                                                                                     + reach);
  450|       |
  451|  1.57M|            float cumulative_reach_probabilities_of_bettr_no_overlaps = clip(cumulative_reach_probabilities_of_hands_no_overlaps - cumulative_reach_probabilities_of_equal_no_overlaps
  452|  1.57M|                                                                                                                                 - cumulative_reach_probabilities_of_worse_no_overlaps);
  453|       |
  454|  1.57M|            float utility = gs.pot_size * 0.5f;
  455|  1.57M|            expected_utilities[c1 - 1][c2 - 1] = cumulative_reach_probabilities_of_worse_no_overlaps * utility - cumulative_reach_probabilities_of_bettr_no_overlaps * utility;
  456|  1.57M|        }
  457|       |
  458|  1.57M|        for (const auto& [reach, c1, c2] : strength_map[strength]) {
  459|  1.57M|            row_reach_sums_worse[c1 - 1] += reach;
  460|  1.57M|            col_reach_sums_worse[c2 - 1] += reach;
  461|  1.57M|        }
  462|   119k|    }
  463|       |
  464|  3.39k|    return expected_utilities;
  465|  5.60k|}

/Users/glen/cfr/shortdecknoluckupdate/src/cfr.cpp:
    1|       |#include "cfr.h"
    2|       |
    3|       |std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE> regret_sum;
    4|       |std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE> strategy_sum;
    5|       |
    6|       |void save_cfr_data(const std::string& filename,
    7|       |                        const std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& regret_sum,
    8|      1|                        const std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& strategy_sum) {
    9|      1|    std::ofstream file(filename, std::ios::binary);
   10|      1|    if (!file) {
   11|      0|        throw std::runtime_error("Unable to open file for writing: " + filename);
   12|      0|    }
   13|       |
   14|       |    // Save regret_sum
   15|      1|    file.write(reinterpret_cast<const char*>(regret_sum.data()), 
   16|      1|               sizeof(float) * 7 * STRATEGY_ARRAY_SIZE);
   17|       |
   18|       |    // Save strategy_sum
   19|      1|    file.write(reinterpret_cast<const char*>(strategy_sum.data()), 
   20|      1|               sizeof(float) * 7 * STRATEGY_ARRAY_SIZE);
   21|       |
   22|      1|    file.close();
   23|      1|}
   24|       |
   25|       |void load_cfr_data(const std::string& filename,
   26|       |                        std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& regret_sum,
   27|      9|                        std::array<std::array<float, 7>, STRATEGY_ARRAY_SIZE>& strategy_sum) {
   28|      9|    std::ifstream file(filename, std::ios::binary);
   29|      9|    if (!file) {
   30|      0|        throw std::runtime_error("Unable to open file for reading: " + filename);
   31|      0|    }
   32|       |
   33|       |    // Load regret_sum
   34|      9|    file.read(reinterpret_cast<char*>(regret_sum.data()), 
   35|      9|              sizeof(float) * 7 * STRATEGY_ARRAY_SIZE);
   36|       |
   37|       |    // Load strategy_sum
   38|      9|    file.read(reinterpret_cast<char*>(strategy_sum.data()), 
   39|      9|              sizeof(float) * 7 * STRATEGY_ARRAY_SIZE);
   40|       |
   41|      9|    file.close();
   42|      9|}
   43|       |
   44|   122M|std::array<float, 7> get_strategy(const InfoSet& info_set) {
   45|   122M|    size_t hash = info_set.hash();
   46|   122M|    int actions = info_set.num_actions;
   47|       |
   48|   122M|    std::array<float, 7> regrets = regret_sum[hash];
   49|   122M|    std::array<float, 7> strategy = {0.0f};
   50|   122M|    float normalizing_sum = 0.0f;
   51|       |
   52|       |    // get positive regrets
   53|   421M|    for (int i=0; i<actions; i++) {
   54|   299M|        strategy[i] = std::max(0.0f, regrets[i]);
   55|   299M|        normalizing_sum += strategy[i];
   56|   299M|    }
   57|       |    
   58|   123M|    if (normalizing_sum > 1e-9f) {
   59|   424M|        for (int i=0; i<actions; i++) strategy[i] /= normalizing_sum;
   60|  18.4E|    } else {
   61|  18.4E|        float uniform_prob = 1.0f / actions;
   62|  18.4E|        for (int i=0; i<actions; i++) strategy[i] = uniform_prob;
   63|  18.4E|    }
   64|       |
   65|   122M|    return strategy;
   66|   122M|}
   67|       |
   68|  1.81M|std::array<float, 7> get_average_strategy(const InfoSet& info_set) {
   69|  1.81M|    size_t hash = info_set.hash();
   70|  1.81M|    int actions = info_set.num_actions;
   71|       |
   72|  1.81M|    std::array<float, 7> avg_strategy = {0.0f};
   73|  1.81M|    float normalizing_sum = 0.0f;
   74|       |
   75|  6.44M|    for (int i=0; i<actions; i++) {
   76|  4.62M|        normalizing_sum += strategy_sum[hash][i];
   77|  4.62M|    }
   78|       |    
   79|  1.81M|    if (normalizing_sum > 1e-9f) {
   80|  6.27M|        for (int i=0; i<actions; i++) {
   81|  4.50M|            avg_strategy[i] = strategy_sum[hash][i] / normalizing_sum;
   82|  4.50M|        }
   83|  1.76M|    } else {
   84|  53.2k|        float uniform_prob = 1.0f / actions;
   85|   168k|        for (int i=0; i<actions; i++) avg_strategy[i] = uniform_prob;
   86|  53.2k|    }
   87|       |
   88|  1.81M|    return avg_strategy;
   89|  1.81M|}
   90|       |
   91|      0|int sample_action(const std::array<float, 7>& strategy) {
   92|       |
   93|      0|    float random_value = get_uniform_distribution()(get_random_generator());
   94|      0|    float cumulative_sum = 0.0f;
   95|       |
   96|      0|    for (int i=0; i<7; ++i) {
   97|      0|        cumulative_sum += strategy[i];
   98|      0|        if (random_value <= cumulative_sum) {
   99|      0|            return i;
  100|      0|        }
  101|      0|    }
  102|       |
  103|      0|    return 0;
  104|      0|}
  105|       |
  106|       |void as_mccfr(int iterations, std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
  107|       |                                   std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
  108|       |                                   std::array<uint8_t, 5> board_cards,
  109|      0|                                   float pot_size) {
  110|       |
  111|      0|    double total_time = 0.0;
  112|      0|    auto start = std::chrono::high_resolution_clock::now();
  113|       |
  114|      0|    std::array<float, 7> init = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};
  115|      0|    for (int i=0; i<STRATEGY_ARRAY_SIZE; i++) {
  116|      0|        strategy_sum[i] = init;
  117|      0|        regret_sum[i] = init;
  118|      0|    }
  119|       |
  120|      0|    try {
  121|      0|        load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
  122|      0|    } catch (const std::runtime_error& e) {
  123|      0|        std::cerr << "Error: " << e.what() << std::endl;
  124|      0|    }
  125|       |
  126|      0|    const int num_threads = std::thread::hardware_concurrency();
  127|      0|    std::vector<std::thread> threads;
  128|      0|    int chunk_size = iterations / num_threads;
  129|       |
  130|      0|    for (int i = 0; i < num_threads; ++i) {
  131|      0|        int start = i * chunk_size;
  132|      0|        int end = (i == num_threads - 1) ? iterations : start + chunk_size;
  133|      0|        threads.emplace_back(as_mccfr_worker, start, end, op_range, ip_range, board_cards, pot_size);
  134|      0|    }
  135|       |
  136|      0|    for (auto& thread : threads) {
  137|      0|        thread.join();
  138|      0|    }
  139|       |
  140|      0|    save_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
  141|       |
  142|      0|    auto end = std::chrono::high_resolution_clock::now();
  143|      0|    std::chrono::duration<double> elapsed = end - start;
  144|      0|    total_time += elapsed.count();
  145|       |
  146|      0|    std::cout << iterations << " iterations of Parallel AS-MCCFR: "
  147|      0|              << total_time << " seconds. " << iterations/total_time << " iterations/second." << "\n";
  148|      0|}
  149|       |
  150|       |void as_mccfr_worker(int start, int end, std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
  151|       |                                              std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
  152|       |                                              std::array<uint8_t, 5> board_cards,
  153|      0|                                              float pot_size) {
  154|      0|    for (int t=start; t<end; t++) {    
  155|      0|        int iteration = t - start + 1.0f;    
  156|      0|        for (int player=0; player<2; player++) {
  157|      0|            GameState state;
  158|      0|            state.pfp_history = 0b111001;
  159|      0|            state.flp_history = 0b1001;
  160|      0|            state.pot_size = pot_size;
  161|      0|            state.flp_seen = true;
  162|      0|            state.trn_seen = true;
  163|      0|            state.bets.push(0.0f);
  164|      0|            state.fp1 = board_cards[0];
  165|      0|            state.fp2 = board_cards[1];
  166|      0|            state.fp3 = board_cards[2];
  167|      0|            state.trn = board_cards[3];
  168|      0|            state.rvr = board_cards[4];
  169|       |
  170|      0|            as_traverse_tree(state, player, 1.0f);
  171|      0|        }
  172|      0|        if (iteration%1000000==0) std::cout << "iteration " << iteration << " complete.\n";
  173|      0|    }
  174|      0|}
  175|       |
  176|      0|float as_traverse_tree(GameState& gs, bool active_player, float q) {
  177|       |    // Terminal
  178|      0|    if (gs.is_terminal) return gs.utility(active_player) / q;
  179|       |
  180|       |    // Chance
  181|      0|    if (gs.is_chance()) {
  182|      0|        uint8_t c = get_card_distribution()(get_random_generator());
  183|      0|        while (gs.has_card(c)) 
  184|      0|            c = get_card_distribution()(get_random_generator());
  185|       |
  186|      0|        bool player_temp = gs.player; float pot_size_temp = gs.pot_size;
  187|      0|        gs.deal_card(c);
  188|      0|        float res = as_traverse_tree(gs, active_player, q);
  189|      0|        gs.undo(player_temp, pot_size_temp);
  190|       |
  191|      0|        return res;
  192|      0|    }
  193|       |
  194|      0|    InfoSet info_set = gs.to_information_set();
  195|      0|    int actions = info_set.num_actions;
  196|      0|    size_t hash = info_set.hash();
  197|      0|    std::array<float, 7> strategy = get_strategy(info_set);
  198|       |
  199|      0|    if (info_set.player != active_player) {
  200|      0|        for (int a=0; a<actions; a++) {
  201|      0|            strategy_sum[hash][a] += strategy[a] / q;
  202|      0|        }
  203|       |
  204|       |        // Sample inactive player's action and compute utility for it
  205|      0|        int sampled_action = sample_action(strategy);
  206|       |        
  207|      0|        bool player_temp = gs.player; float pot_size_temp = gs.pot_size;
  208|      0|        gs.apply_index(sampled_action);
  209|      0|        float res = as_traverse_tree(gs, active_player, q);
  210|      0|        gs.undo(player_temp, pot_size_temp);
  211|       |
  212|      0|        return res;
  213|      0|    }
  214|       |
  215|       |    // Active player's turn
  216|       |
  217|      0|    std::array<float, 7> action_utils = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};
  218|      0|    float node_util = 0;
  219|      0|    float sum_over_all_actions = 0;
  220|       |
  221|      0|    for (int a=0; a<actions; a++) {
  222|      0|        sum_over_all_actions += strategy_sum[hash][a];
  223|      0|    }
  224|       |    
  225|      0|    for (int a=0; a<actions; a++) {
  226|      0|        float res = (BETA + TAU * strategy_sum[hash][a]) / 
  227|      0|                    (BETA + sum_over_all_actions);
  228|      0|        float p = std::max(EPSILON, res);
  229|      0|        float r = get_uniform_distribution()(get_random_generator());
  230|       |
  231|      0|        if (r < p) {
  232|      0|            GameState child = gs;
  233|      0|            bool player_temp = gs.player; float pot_size_temp = gs.pot_size;
  234|      0|            gs.apply_index(a);
  235|      0|            action_utils[a] = as_traverse_tree(gs, active_player, q * std::min(1.0f, p));
  236|      0|            gs.undo(player_temp, pot_size_temp);
  237|      0|        }
  238|       |
  239|      0|        node_util += strategy[a] * action_utils[a];
  240|      0|    }
  241|       |
  242|      0|    for (int a=0; a<actions; a++) {
  243|      0|        regret_sum[hash][a] = regret_sum[hash][a] + action_utils[a] - node_util;
  244|      0|    }
  245|       |
  246|      0|    return node_util;
  247|      0|}
  248|       |
  249|       |void add_2d_arrays_simd(std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& a,
  250|       |                        const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& b,
  251|   100M|                        std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& result) {
  252|   100M|    constexpr int SIMD_WIDTH = 8; // Number of floats in __m256
  253|   100M|    constexpr int TOTAL_ELEMENTS = NUM_CARDS * NUM_CARDS;
  254|   100M|    constexpr int SIMD_ITERATIONS = TOTAL_ELEMENTS / SIMD_WIDTH;
  255|       |
  256|   100M|    float* a_ptr = reinterpret_cast<float*>(a.data());
  257|   100M|    const float* b_ptr = reinterpret_cast<const float*>(b.data());
  258|   100M|    float* result_ptr = reinterpret_cast<float*>(result.data());
  259|       |
  260|  16.3G|    for (int i = 0; i < SIMD_ITERATIONS; ++i) {
  261|  16.2G|        __m256 va = _mm256_loadu_ps(a_ptr + i * SIMD_WIDTH);
  262|  16.2G|        __m256 vb = _mm256_loadu_ps(b_ptr + i * SIMD_WIDTH);
  263|  16.2G|        __m256 vr = _mm256_add_ps(va, vb);
  264|  16.2G|        _mm256_storeu_ps(result_ptr + i * SIMD_WIDTH, vr);
  265|  16.2G|    }
  266|       |
  267|       |    // Handle remaining elements if TOTAL_ELEMENTS is not divisible by SIMD_WIDTH
  268|   100M|    for (int i = SIMD_ITERATIONS * SIMD_WIDTH; i < TOTAL_ELEMENTS; ++i) {
  269|      0|        result_ptr[i] = a_ptr[i] + b_ptr[i];
  270|      0|    }
  271|   100M|}
  272|       |
  273|       |void multiply_2d_arrays_simd(std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& a,
  274|       |                             const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& b,
  275|   280k|                             std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& result) {
  276|   280k|    constexpr int SIMD_WIDTH = 8; // Number of floats in __m256
  277|   280k|    constexpr int TOTAL_ELEMENTS = NUM_CARDS * NUM_CARDS;
  278|   280k|    constexpr int SIMD_ITERATIONS = TOTAL_ELEMENTS / SIMD_WIDTH;
  279|       |
  280|   280k|    float* a_ptr = reinterpret_cast<float*>(a.data());
  281|   280k|    const float* b_ptr = reinterpret_cast<const float*>(b.data());
  282|   280k|    float* result_ptr = reinterpret_cast<float*>(result.data());
  283|       |
  284|  45.5M|    for (int i = 0; i < SIMD_ITERATIONS; ++i) {
  285|  45.2M|        __m256 va = _mm256_loadu_ps(a_ptr + i * SIMD_WIDTH);
  286|  45.2M|        __m256 vb = _mm256_loadu_ps(b_ptr + i * SIMD_WIDTH);
  287|  45.2M|        __m256 vr = _mm256_mul_ps(va, vb);  // Changed from add_ps to mul_ps
  288|  45.2M|        _mm256_storeu_ps(result_ptr + i * SIMD_WIDTH, vr);
  289|  45.2M|    }
  290|       |
  291|       |    // Handle remaining elements if TOTAL_ELEMENTS is not divisible by SIMD_WIDTH
  292|   280k|    for (int i = SIMD_ITERATIONS * SIMD_WIDTH; i < TOTAL_ELEMENTS; ++i) {
  293|      0|        result_ptr[i] = a_ptr[i] * b_ptr[i];
  294|      0|    }
  295|   280k|}
  296|       |
  297|       |void fast_initialize_arrays(std::array<float, NUM_CARDS>& row_reach_sums_equal,
  298|  6.22M|                            std::array<float, NUM_CARDS>& col_reach_sums_equal) {
  299|  6.22M|    constexpr int SIMD_WIDTH = 8; // Number of floats in __m256
  300|  6.22M|    constexpr int SIMD_ITERATIONS = NUM_CARDS / SIMD_WIDTH;
  301|       |    
  302|  6.22M|    __m256 zero_vector = _mm256_setzero_ps();
  303|       |
  304|  31.1M|    for (int i = 0; i < SIMD_ITERATIONS; ++i) {
  305|  24.8M|        _mm256_storeu_ps(&row_reach_sums_equal[i * SIMD_WIDTH], zero_vector);
  306|  24.8M|        _mm256_storeu_ps(&col_reach_sums_equal[i * SIMD_WIDTH], zero_vector);
  307|  24.8M|    }
  308|       |
  309|       |    // Handle any remaining elements
  310|  31.1M|    for (size_t i = SIMD_ITERATIONS * SIMD_WIDTH; i < NUM_CARDS; ++i) {
  311|  24.8M|        row_reach_sums_equal[i] = 0.0f;
  312|  24.8M|        col_reach_sums_equal[i] = 0.0f;
  313|  24.8M|    }
  314|  6.22M|}
  315|       |
  316|       |void cfr_plus_parallel(int iterations, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range,
  317|       |                                   const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
  318|      1|                                   const std::array<uint8_t, 5> board_cards, float pot_size) {
  319|       |
  320|      1|    double total_time = 0.0f;
  321|      1|    auto start = std::chrono::high_resolution_clock::now();
  322|       |
  323|      1|    std::array<float, 7> init = {0.0f};
  324|  5.00M|    for (int i=0; i<STRATEGY_ARRAY_SIZE; i++) {
  325|  5.00M|        strategy_sum[i] = init;
  326|  5.00M|        regret_sum[i] = init;
  327|  5.00M|    }
  328|       |
  329|      1|    try {
  330|      1|        load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
  331|      1|    } catch (const std::runtime_error& e) {
  332|      0|        std::cerr << "Error: " << e.what() << std::endl;
  333|      0|    }
  334|       |
  335|      1|    cfr_plus_worker_parallel(0, iterations, op_range, ip_range, board_cards, pot_size);
  336|       |
  337|      1|    save_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
  338|       |
  339|      1|    auto end = std::chrono::high_resolution_clock::now();
  340|      1|    std::chrono::duration<double> elapsed = end - start;
  341|      1|    total_time += elapsed.count();
  342|       |
  343|      1|    std::cout << iterations << " iterations of CFR+: "
  344|      1|              << total_time << " seconds. " << iterations/total_time << " iterations/second." << "\n";
  345|      1|}
  346|       |
  347|       |void cfr_plus_worker_parallel(int start, int end, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
  348|       |                                                  const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
  349|      1|                                                  std::array<uint8_t, 5> board_cards, float pot_size) {
  350|       |
  351|     51|    for (int t=start; t<end; t++) {
  352|       |
  353|     50|        GameState state;
  354|     50|        state.pfp_history = 0b111001;
  355|     50|        state.flp_history = 0b1001;
  356|     50|        state.pot_size = pot_size;
  357|     50|        state.flp_seen = true;
  358|     50|        state.trn_seen = true;
  359|     50|        state.bets.push(0.0f);
  360|       |
  361|     50|        state.fp1 = board_cards[0];
  362|     50|        state.fp2 = board_cards[1];
  363|     50|        state.fp3 = board_cards[2];
  364|     50|        state.trn = board_cards[3];
  365|     50|        state.rvr = board_cards[4];
  366|       |
  367|     50|        float delay = 0.0f;
  368|     50|        float iteration = t - start + 1.0f;
  369|     50|        float weight = std::max(iteration - delay, 0.0f);
  370|     50|        const auto ones = create_ones_array();
  371|       |
  372|     50|        int num_threads = get_cpu_cores();
  373|     50|        ThreadPool pool(num_threads);
  374|       |
  375|     50|        cfr_plus_traverse_tree_fast_parallel(state, 0, weight, ones, ip_range, op_range, pool);
  376|     50|        cfr_plus_traverse_tree_fast_parallel(state, 1, weight, ones, op_range, ip_range, pool);
  377|       |
  378|       |        // dcfr_traverse_tree_fast(state, 0, weight, ones, ip_range, op_range);
  379|       |        // dcfr_traverse_tree_fast(state, 1, weight, ones, op_range, ip_range);
  380|       |        
  381|       |        // lcfr_traverse_tree_fast(state, 0, weight, ones, ip_range, op_range);
  382|       |        // lcfr_traverse_tree_fast(state, 1, weight, ones, op_range, ip_range);
  383|       |
  384|     50|        if ((t-start+1)%1==0) std::cout << "t=" << t-start+1 << "\n";
  385|     50|    }
  386|      1|}
  387|       |
  388|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> cfr_plus_traverse_tree_fast_parallel(
  389|       |    GameState& state, bool traversing_player, float weight,
  390|       |    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
  391|       |    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
  392|       |    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range,
  393|   450k|    ThreadPool& pool) {
  394|       |
  395|       |    // Terminal case remains the same
  396|   450k|    if (state.is_terminal) return expected_utility_fast_cfr_plus(state, traversing_player, reach_probabilities, inactive_player_range, traversing_player_range);
  397|       |
  398|   169k|    auto info_set_utilities = std::make_unique<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>();
  399|  6.22M|    for (int r=0; r<NUM_CARDS; r++) (*info_set_utilities)[r].fill(0.0f);
  400|       |
  401|   169k|    if (state.is_chance()) {
  402|  1.90k|        int num = state.num_in_deck();
  403|  1.90k|        std::vector<std::future<std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>>> futures;
  404|       |        
  405|  70.3k|        for (int c = 1; c <= NUM_CARDS; c++) {
  406|  68.4k|            if (state.has_card(c)) continue;
  407|  60.8k|            futures.push_back(pool.enqueue([&, c]() {
  408|  60.7k|                GameState thread_state = state;
  409|  60.7k|                thread_state.deal_card(c);
  410|  60.7k|                auto new_reach_probabilities = update_chance_reach_probabilities_cfr_plus(thread_state, num, reach_probabilities);
  411|  60.7k|                return cfr_plus_traverse_tree_fast_parallel(thread_state, traversing_player, weight, *new_reach_probabilities, inactive_player_range, traversing_player_range, pool);
  412|  60.7k|            }));
  413|  60.8k|        }
  414|       |
  415|       |        // Collect and combine results
  416|  60.8k|        for (auto& future : futures) {
  417|  60.8k|            auto result = future.get();
  418|  60.8k|            add_2d_arrays_simd(*info_set_utilities, *result, *info_set_utilities);
  419|  60.8k|        }
  420|       |
  421|  1.90k|        return info_set_utilities;
  422|  1.90k|    }
  423|       |
  424|   168k|    InfoSet is = state.to_information_set();
  425|   168k|    int actions = state.num_actions();
  426|       |
  427|   168k|    auto action_vals = std::make_unique<std::array<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>, 7>>();
  428|       |
  429|   168k|    if (state.player == traversing_player) {
  430|   278k|        for (int a=0; a<actions; a++) {
  431|   194k|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  432|   194k|            state.apply_index(a);
  433|   194k|            auto temp = cfr_plus_traverse_tree_fast_parallel(state, traversing_player, weight, reach_probabilities, inactive_player_range, traversing_player_range, pool);
  434|   194k|            state.undo(player_temp, pot_size_temp);
  435|       |
  436|   194k|            (*action_vals)[a] = *temp;
  437|   194k|        }
  438|  3.09M|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  439|  51.3M|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  440|  48.2M|                if (!(state.has_card(c1) || state.has_card(c2))) {
  441|  36.1M|                    is.cr1 = c1; is.cr2 = c2;
  442|  36.1M|                    std::array<float, 7> strategy = get_strategy(is);
  443|       |
  444|   118M|                    for (int a=0; a<actions; a++) {
  445|  81.9M|                        (*info_set_utilities)[c1 - 1][c2 - 1] += strategy[a] * (*action_vals)[a][c1 - 1][c2 - 1];
  446|  81.9M|                    }
  447|  36.1M|                }
  448|  48.2M|            }
  449|  3.00M|        }
  450|  3.08M|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  451|  49.3M|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  452|  46.3M|                if (!(state.has_card(c1) || state.has_card(c2))) {
  453|   111M|                    for (int a=0; a<actions; a++) {
  454|  75.5M|                        is.cr1 = c1; is.cr2 = c2;
  455|  75.5M|                        int hash = is.hash();
  456|  75.5M|                        regret_sum[hash][a] = std::max(regret_sum[hash][a] + (*action_vals)[a][c1 - 1][c2 - 1] - (*info_set_utilities)[c1 - 1][c2 - 1], 0.0f);
  457|  75.5M|                    }
  458|  36.1M|                }
  459|  46.3M|            }
  460|  2.99M|        }
  461|  84.1k|    } else {
  462|   278k|        for (int a=0; a<actions; a++) {
  463|   194k|            auto new_reach_probabilities = update_reach_probabilities_cfr_plus(state, a, reach_probabilities);
  464|       |
  465|   194k|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  466|   194k|            state.apply_index(a);
  467|   194k|            auto temp = cfr_plus_traverse_tree_fast_parallel(state, traversing_player, weight, *new_reach_probabilities, inactive_player_range, traversing_player_range, pool);
  468|   194k|            state.undo(player_temp, pot_size_temp);
  469|       |
  470|   194k|            add_2d_arrays_simd(*info_set_utilities, *temp, *info_set_utilities);
  471|   194k|        }
  472|       |
  473|  3.09M|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  474|  51.3M|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  475|  48.2M|                if (!(state.has_card(c1) || state.has_card(c2))) {
  476|  36.3M|                    is.cr1 = c1; is.cr2 = c2;
  477|  36.3M|                    int hash = is.hash();
  478|  36.3M|                    std::array<float, 7> strategy = get_strategy(is);
  479|       |
  480|   115M|                    for (int a=0; a<actions; a++) {
  481|  79.0M|                        strategy_sum[hash][a] = strategy_sum[hash][a] + weight * reach_probabilities[c1 - 1][c2 - 1] * strategy[a];
  482|  79.0M|                    }
  483|  36.3M|                }
  484|  48.2M|            }
  485|  3.00M|        }
  486|  83.9k|    }
  487|       |
  488|   168k|    return info_set_utilities;
  489|   169k|}
  490|       |
  491|       |
  492|       |
  493|       |
  494|       |
  495|       |
  496|       |void cfr_plus(int iterations, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range,
  497|       |                                   const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
  498|      0|                                   const std::array<uint8_t, 5> board_cards, float pot_size) {
  499|       |
  500|      0|    double total_time = 0.0f;
  501|      0|    auto start = std::chrono::high_resolution_clock::now();
  502|       |
  503|      0|    std::array<float, 7> init = {0.0f};
  504|      0|    for (int i=0; i<STRATEGY_ARRAY_SIZE; i++) {
  505|      0|        strategy_sum[i] = init;
  506|      0|        regret_sum[i] = init;
  507|      0|    }
  508|       |
  509|      0|    try {
  510|      0|        load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
  511|      0|    } catch (const std::runtime_error& e) {
  512|      0|        std::cerr << "Error: " << e.what() << std::endl;
  513|      0|    }
  514|       |
  515|      0|    const int num_threads = 1;
  516|      0|    std::vector<std::thread> threads;
  517|      0|    int chunk_size = iterations / num_threads;
  518|       |
  519|      0|    for (int thread_id = 0; thread_id < num_threads; thread_id++) {
  520|      0|        int start = thread_id * chunk_size;
  521|      0|        int end = (thread_id == num_threads - 1) ? iterations : start + chunk_size;
  522|      0|        threads.emplace_back(cfr_plus_worker, start, end, op_range, ip_range, board_cards, pot_size, thread_id);
  523|      0|    }
  524|       |
  525|      0|    for (auto& thread : threads) {
  526|      0|        thread.join();
  527|      0|    }
  528|       |
  529|      0|    save_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
  530|       |
  531|      0|    auto end = std::chrono::high_resolution_clock::now();
  532|      0|    std::chrono::duration<double> elapsed = end - start;
  533|      0|    total_time += elapsed.count();
  534|       |
  535|      0|    std::cout << iterations << " iterations of CFR+: "
  536|      0|              << total_time << " seconds. " << iterations/total_time << " iterations/second." << "\n";
  537|      0|}
  538|       |
  539|       |void cfr_plus_worker(int start, int end, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> op_range, 
  540|       |                                              const std::array<std::array<float, NUM_CARDS>, NUM_CARDS> ip_range, 
  541|      0|                                              std::array<uint8_t, 5> board_cards, float pot_size, int thread_id) {
  542|      0|    for (int t=start; t<end; t++) {
  543|       |
  544|      0|        GameState state;
  545|      0|        state.pfp_history = 0b111001;
  546|      0|        state.flp_history = 0b1001;
  547|      0|        state.pot_size = pot_size;
  548|      0|        state.flp_seen = true;
  549|      0|        state.trn_seen = true;
  550|      0|        state.bets.push(0.0f);
  551|       |
  552|      0|        state.fp1 = board_cards[0];
  553|      0|        state.fp2 = board_cards[1];
  554|      0|        state.fp3 = board_cards[2];
  555|      0|        state.trn = board_cards[3];
  556|      0|        state.rvr = board_cards[4];
  557|       |
  558|      0|        float delay = 0.0f;
  559|      0|        float iteration = t - start + 1.0f;
  560|      0|        float weight = std::max(iteration - delay, 0.0f);
  561|      0|        const auto ones = create_ones_array();
  562|       |
  563|      0|        cfr_plus_traverse_tree_fast(state, 0, weight, ones, ip_range, op_range);
  564|      0|        cfr_plus_traverse_tree_fast(state, 1, weight, ones, op_range, ip_range);
  565|       |
  566|       |        // dcfr_traverse_tree_fast(state, 0, weight, ones, ip_range, op_range);
  567|       |        // dcfr_traverse_tree_fast(state, 1, weight, ones, op_range, ip_range);
  568|       |        
  569|       |        // lcfr_traverse_tree_fast(state, 0, weight, ones, ip_range, op_range);
  570|       |        // lcfr_traverse_tree_fast(state, 1, weight, ones, op_range, ip_range);
  571|       |
  572|      0|        if ((t-start+1)%1==0) std::cout << "t=" << t-start+1 << "\n";
  573|      0|    }
  574|      0|}
  575|       |
  576|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> cfr_plus_traverse_tree_fast(GameState& state, bool traversing_player, float weight,
  577|       |                                                                                                 const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
  578|       |                                                                                                 const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
  579|      0|                                                                                                 const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range) {
  580|       |    // Terminal
  581|      0|    if (state.is_terminal) return expected_utility_fast_cfr_plus(state, traversing_player, reach_probabilities, inactive_player_range, traversing_player_range);
  582|       |
  583|      0|    auto info_set_utilities = std::make_unique<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>();
  584|      0|    for (int r=0; r<NUM_CARDS; r++) (*info_set_utilities)[r].fill(0.0f);
  585|       |
  586|       |    // Chance
  587|      0|    if (state.is_chance()) {
  588|      0|        int num = state.num_in_deck();
  589|       |
  590|      0|        for (int c=1; c<=NUM_CARDS; c++) {
  591|      0|            if (state.has_card(c)) continue;
  592|       |
  593|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  594|      0|            state.deal_card(c);
  595|      0|            auto new_reach_probabilities = update_chance_reach_probabilities_cfr_plus(state, num, reach_probabilities);
  596|      0|            auto temp = cfr_plus_traverse_tree_fast(state, traversing_player, weight, *new_reach_probabilities, inactive_player_range, traversing_player_range);
  597|      0|            state.undo(player_temp, pot_size_temp);
  598|       |
  599|      0|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  600|      0|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  601|      0|                    if (!(state.has_card(c1) || state.has_card(c2) || (c1==c) || (c2==c))) {
  602|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += (*temp)[c1 - 1][c2 - 1];
  603|      0|                    }
  604|      0|                }
  605|      0|            }
  606|      0|        }
  607|      0|        return info_set_utilities;
  608|      0|    }
  609|       |
  610|      0|    InfoSet is = state.to_information_set();
  611|      0|    int actions = state.num_actions();
  612|       |
  613|      0|    auto action_vals = std::make_unique<std::array<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>, 7>>();
  614|      0|    for (int a=0; a<7; a++) {
  615|      0|        for (int r=0; r<NUM_CARDS; r++) (*action_vals)[a][r].fill(0.0f);
  616|      0|    }
  617|       |
  618|      0|    if (state.player == traversing_player) {
  619|      0|        for (int a=0; a<actions; a++) {
  620|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  621|      0|            state.apply_index(a);
  622|      0|            auto temp = cfr_plus_traverse_tree_fast(state, traversing_player, weight, reach_probabilities, inactive_player_range, traversing_player_range);
  623|      0|            state.undo(player_temp, pot_size_temp);
  624|       |
  625|      0|            (*action_vals)[a] = *temp;
  626|      0|        }
  627|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  628|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  629|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  630|      0|                    is.cr1 = c1; is.cr2 = c2;
  631|      0|                    std::array<float, 7> strategy = get_strategy(is);
  632|       |
  633|      0|                    for (int a=0; a<actions; a++) {
  634|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += strategy[a] * (*action_vals)[a][c1 - 1][c2 - 1];
  635|      0|                    }
  636|      0|                }
  637|      0|            }
  638|      0|        }
  639|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  640|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  641|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  642|      0|                    for (int a=0; a<actions; a++) {
  643|      0|                        is.cr1 = c1; is.cr2 = c2;
  644|      0|                        int hash = is.hash();
  645|      0|                        regret_sum[hash][a] = std::max(regret_sum[hash][a] + (*action_vals)[a][c1 - 1][c2 - 1] - (*info_set_utilities)[c1 - 1][c2 - 1], 0.0f);
  646|      0|                    }
  647|      0|                }
  648|      0|            }
  649|      0|        }
  650|      0|    } else {
  651|      0|        for (int a=0; a<actions; a++) {
  652|      0|            auto new_reach_probabilities = update_reach_probabilities_cfr_plus(state, a, reach_probabilities);
  653|       |
  654|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  655|      0|            state.apply_index(a);
  656|      0|            auto temp = cfr_plus_traverse_tree_fast(state, traversing_player, weight, *new_reach_probabilities, inactive_player_range, traversing_player_range);
  657|      0|            state.undo(player_temp, pot_size_temp);
  658|       |        
  659|      0|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  660|      0|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  661|      0|                    if (!(state.has_card(c1) || state.has_card(c2))) {
  662|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += (*temp)[c1 - 1][c2 - 1];
  663|      0|                    }
  664|      0|                }
  665|      0|            }
  666|      0|        }
  667|       |
  668|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  669|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  670|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  671|      0|                    is.cr1 = c1; is.cr2 = c2;
  672|      0|                    int hash = is.hash();
  673|      0|                    std::array<float, 7> strategy = get_strategy(is);
  674|       |
  675|      0|                    for (int a=0; a<actions; a++) {
  676|      0|                        strategy_sum[hash][a] = strategy_sum[hash][a] + weight * reach_probabilities[c1 - 1][c2 - 1] * strategy[a];
  677|      0|                    }
  678|      0|                }
  679|      0|            }
  680|      0|        }
  681|      0|    }
  682|       |
  683|      0|    return info_set_utilities;
  684|      0|}
  685|       |
  686|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> lcfr_traverse_tree_fast(GameState& state, bool traversing_player, float weight,
  687|       |                                                                                                  const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
  688|       |                                                                                                  const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
  689|      0|                                                                                                  const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range) {
  690|       |    // Terminal
  691|      0|    if (state.is_terminal) return expected_utility_fast_cfr_plus(state, traversing_player, reach_probabilities, inactive_player_range, traversing_player_range);
  692|       |
  693|      0|    auto info_set_utilities = std::make_unique<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>();
  694|      0|    for (int r=0; r<NUM_CARDS; r++) (*info_set_utilities)[r].fill(0.0f);
  695|       |
  696|       |    // Chance
  697|      0|    if (state.is_chance()) {
  698|      0|        int num = state.num_in_deck();
  699|       |
  700|      0|        for (int c=1; c<=NUM_CARDS; c++) {
  701|      0|            if (state.has_card(c)) continue;
  702|       |
  703|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  704|      0|            state.deal_card(c);
  705|      0|            auto new_reach_probabilities = update_chance_reach_probabilities_cfr_plus(state, num, reach_probabilities);
  706|      0|            auto temp = lcfr_traverse_tree_fast(state, traversing_player, weight, *new_reach_probabilities, inactive_player_range, traversing_player_range);
  707|      0|            state.undo(player_temp, pot_size_temp);
  708|       |
  709|      0|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  710|      0|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  711|      0|                    if (!(state.has_card(c1) || state.has_card(c2) || (c1==c) || (c2==c))) {
  712|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += (*temp)[c1 - 1][c2 - 1];
  713|      0|                    }
  714|      0|                }
  715|      0|            }
  716|      0|        }
  717|      0|        return info_set_utilities;
  718|      0|    }
  719|       |
  720|      0|    InfoSet is = state.to_information_set();
  721|      0|    int actions = is.num_actions;
  722|       |
  723|      0|    auto action_vals = std::make_unique<std::array<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>, 7>>();
  724|      0|    for (int a=0; a<7; a++) {
  725|      0|        for (int r=0; r<NUM_CARDS; r++) (*action_vals)[a][r].fill(0.0f);
  726|      0|    }
  727|       |
  728|      0|    if (state.player == traversing_player) {
  729|      0|        for (int a=0; a<actions; a++) {
  730|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  731|      0|            state.apply_index(a);
  732|      0|            auto temp = lcfr_traverse_tree_fast(state, traversing_player, weight, reach_probabilities, inactive_player_range, traversing_player_range);
  733|      0|            state.undo(player_temp, pot_size_temp);
  734|       |
  735|      0|            (*action_vals)[a] = *temp;
  736|      0|        }
  737|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  738|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  739|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  740|      0|                    is.cr1 = c1; is.cr2 = c2;
  741|      0|                    std::array<float, 7> strategy = get_strategy(is);
  742|       |
  743|      0|                    for (int a=0; a<actions; a++) {
  744|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += strategy[a] * (*action_vals)[a][c1 - 1][c2 - 1];
  745|      0|                    }
  746|      0|                }
  747|      0|            }
  748|      0|        }
  749|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  750|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  751|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  752|      0|                    for (int a=0; a<actions; a++) {
  753|      0|                        is.cr1 = c1; is.cr2 = c2;
  754|      0|                        int hash = is.hash();
  755|      0|                        regret_sum[hash][a] += weight * ((*action_vals)[a][c1 - 1][c2 - 1] - (*info_set_utilities)[c1 - 1][c2 - 1]);
  756|      0|                    }
  757|      0|                }
  758|      0|            }
  759|      0|        }
  760|      0|    } else {
  761|      0|        for (int a=0; a<actions; a++) {
  762|      0|            auto new_reach_probabilities = update_reach_probabilities_cfr_plus(state, a, reach_probabilities);
  763|       |
  764|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  765|      0|            state.apply_index(a);
  766|      0|            auto temp = lcfr_traverse_tree_fast(state, traversing_player, weight, *new_reach_probabilities, inactive_player_range, traversing_player_range);
  767|      0|            state.undo(player_temp, pot_size_temp);
  768|       |        
  769|      0|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  770|      0|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  771|      0|                    if (!(state.has_card(c1) || state.has_card(c2))) {
  772|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += (*temp)[c1 - 1][c2 - 1];
  773|      0|                    }
  774|      0|                }
  775|      0|            }
  776|      0|        }
  777|       |
  778|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  779|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  780|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  781|      0|                    is.cr1 = c1; is.cr2 = c2;
  782|      0|                    int hash = is.hash();
  783|      0|                    std::array<float, 7> strategy = get_strategy(is);
  784|       |
  785|      0|                    for (int a=0; a<actions; a++) {
  786|      0|                        strategy_sum[hash][a] += weight * reach_probabilities[c1 - 1][c2 - 1] * strategy[a];
  787|      0|                    }
  788|      0|                }
  789|      0|            }
  790|      0|        }
  791|      0|    }
  792|       |
  793|      0|    return info_set_utilities;
  794|      0|}
  795|       |
  796|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> dcfr_traverse_tree_fast(GameState& state, bool traversing_player, int iteration,
  797|       |                                                                                                  const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities,
  798|       |                                                                                                  const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
  799|      0|                                                                                                  const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range) {
  800|       |    // Terminal
  801|      0|    if (state.is_terminal) return expected_utility_fast_cfr_plus(state, traversing_player, reach_probabilities, inactive_player_range, traversing_player_range);
  802|       |
  803|      0|    auto info_set_utilities = std::make_unique<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>();
  804|      0|    for (int r=0; r<NUM_CARDS; r++) (*info_set_utilities)[r].fill(0.0f);
  805|       |
  806|       |    // Chance
  807|      0|    if (state.is_chance()) {
  808|      0|        int num = state.num_in_deck();
  809|       |
  810|      0|        for (int c=1; c<=NUM_CARDS; c++) {
  811|      0|            if (state.has_card(c)) continue;
  812|       |
  813|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  814|      0|            state.deal_card(c);
  815|      0|            auto new_reach_probabilities = update_chance_reach_probabilities_cfr_plus(state, num, reach_probabilities);
  816|      0|            auto temp = dcfr_traverse_tree_fast(state, traversing_player, iteration, *new_reach_probabilities, inactive_player_range, traversing_player_range);
  817|      0|            state.undo(player_temp, pot_size_temp);
  818|       |
  819|      0|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  820|      0|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  821|      0|                    if (!(state.has_card(c1) || state.has_card(c2) || (c1==c) || (c2==c))) {
  822|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += (*temp)[c1 - 1][c2 - 1];
  823|      0|                    }
  824|      0|                }
  825|      0|            }
  826|      0|        }
  827|      0|        return info_set_utilities;
  828|      0|    }
  829|       |
  830|      0|    InfoSet is = state.to_information_set();
  831|      0|    int actions = is.num_actions;
  832|       |
  833|      0|    auto action_vals = std::make_unique<std::array<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>, 7>>();
  834|      0|    for (int a=0; a<7; a++) {
  835|      0|        for (int r=0; r<NUM_CARDS; r++) (*action_vals)[a][r].fill(0.0f);
  836|      0|    }
  837|       |
  838|      0|    if (state.player == traversing_player) {
  839|      0|        for (int a=0; a<actions; a++) {
  840|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  841|      0|            state.apply_index(a);
  842|      0|            auto temp = dcfr_traverse_tree_fast(state, traversing_player, iteration, reach_probabilities, inactive_player_range, traversing_player_range);
  843|      0|            state.undo(player_temp, pot_size_temp);
  844|       |
  845|      0|            (*action_vals)[a] = *temp;
  846|      0|        }
  847|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  848|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  849|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  850|      0|                    is.cr1 = c1; is.cr2 = c2;
  851|      0|                    std::array<float, 7> strategy = get_strategy(is);
  852|       |
  853|      0|                    for (int a=0; a<actions; a++) {
  854|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += strategy[a] * (*action_vals)[a][c1 - 1][c2 - 1];
  855|      0|                    }
  856|      0|                }
  857|      0|            }
  858|      0|        }
  859|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  860|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  861|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  862|      0|                    for (int a=0; a<actions; a++) {
  863|      0|                        is.cr1 = c1; is.cr2 = c2;
  864|      0|                        int hash = is.hash();
  865|      0|                        regret_sum[hash][a] += ((*action_vals)[a][c1 - 1][c2 - 1] - (*info_set_utilities)[c1 - 1][c2 - 1]);
  866|       |
  867|      0|                        float t_to_alpha = std::pow(iteration, DCFR_ALPHA);
  868|      0|                        float t_to_beta = std::pow(iteration, DCFR_BETA);
  869|      0|                        float weight = (regret_sum[hash][a] > 0) ? (t_to_alpha / (t_to_alpha + 1.0f)) : (t_to_beta / (t_to_beta + 1.0f));
  870|      0|                        regret_sum[hash][a] *= weight;
  871|      0|                    }
  872|      0|                }
  873|      0|            }
  874|      0|        }
  875|      0|    } else {
  876|      0|        for (int a=0; a<actions; a++) {
  877|      0|            auto new_reach_probabilities = update_reach_probabilities_cfr_plus(state, a, reach_probabilities);
  878|       |
  879|      0|            bool player_temp = state.player; float pot_size_temp = state.pot_size;
  880|      0|            state.apply_index(a);
  881|      0|            auto temp = dcfr_traverse_tree_fast(state, traversing_player, iteration, *new_reach_probabilities, inactive_player_range, traversing_player_range);
  882|      0|            state.undo(player_temp, pot_size_temp);
  883|       |        
  884|      0|            for (int c1=1; c1<=NUM_CARDS; c1++) {
  885|      0|                for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  886|      0|                    if (!(state.has_card(c1) || state.has_card(c2))) {
  887|      0|                        (*info_set_utilities)[c1 - 1][c2 - 1] += (*temp)[c1 - 1][c2 - 1];
  888|      0|                    }
  889|      0|                }
  890|      0|            }
  891|      0|        }
  892|       |
  893|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  894|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  895|      0|                if (!(state.has_card(c1) || state.has_card(c2))) {
  896|      0|                    is.cr1 = c1; is.cr2 = c2;
  897|      0|                    int hash = is.hash();
  898|      0|                    std::array<float, 7> strategy = get_strategy(is);
  899|       |
  900|      0|                    float weight = std::pow((iteration / (iteration + 1.0f)), DCFR_GAMMA);
  901|      0|                    for (int a=0; a<actions; a++) {
  902|      0|                        strategy_sum[hash][a] = strategy_sum[hash][a] + weight * reach_probabilities[c1 - 1][c2 - 1] * strategy[a];
  903|      0|                    }
  904|      0|                }
  905|      0|            }
  906|      0|        }
  907|      0|    }
  908|       |
  909|      0|    return info_set_utilities;
  910|      0|}
  911|       |
  912|   194k|std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> update_reach_probabilities_cfr_plus(GameState state, int action, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
  913|   194k|    auto res = std::make_unique<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>();
  914|  7.16M|    for (int r=0; r<NUM_CARDS; r++) (*res)[r].fill(0.0f);
  915|       |
  916|       |    // Mask out acting player's cards
  917|   194k|    if (state.player==0) { state.op1 = 0; state.op2 = 0; }
  918|  97.1k|    else { state.ip1 = 0; state.ip2 = 0; }
  919|       |
  920|   194k|    InfoSet is = state.to_information_set();
  921|       |
  922|  7.11M|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  923|   109M|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  924|   102M|            if (!(state.has_card(c1) || state.has_card(c2))) {
  925|       |                // Assign acting player their cards
  926|  71.5M|                is.cr1 = c1;
  927|  71.5M|                is.cr2 = c2;
  928|       |
  929|  71.5M|                float action_probability = get_strategy(is)[action];
  930|       |                
  931|  71.5M|                (*res)[c1 - 1][c2 - 1] = (action_probability) * reach_probabilities[c1 - 1][c2 - 1];
  932|  71.5M|            }            
  933|   102M|        }
  934|  6.91M|    }
  935|   194k|    return res;
  936|   194k|}
  937|       |
  938|  60.5k|std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> update_chance_reach_probabilities_cfr_plus(const GameState& state, int num, const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& reach_probabilities) {
  939|  60.5k|    auto res = std::make_unique<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>();
  940|  2.10M|    for (int r=0; r<NUM_CARDS; r++) (*res)[r].fill(0.0f);
  941|       |
  942|  1.38M|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  943|  25.8M|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  944|  25.4M|            if (!(state.has_card(c1) || state.has_card(c2))) {
  945|  20.8M|                (*res)[c1 - 1][c2 - 1] = (1.0f / num) * reach_probabilities[c1 - 1][c2 - 1];
  946|  20.8M|            }
  947|  24.5M|        }
  948|  1.32M|    }
  949|  60.5k|    return res;
  950|  60.5k|}
  951|       |
  952|       |std::unique_ptr<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>> expected_utility_fast_cfr_plus(const GameState& state, bool traversing_player, 
  953|       |                                                                                                    std::array<std::array<float, NUM_CARDS>, NUM_CARDS> reach_probabilities,
  954|       |                                                                                                    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& inactive_player_range,
  955|   280k|                                                                                                    const std::array<std::array<float, NUM_CARDS>, NUM_CARDS>& traversing_player_range) {
  956|   280k|    auto expected_utilities = std::make_unique<std::array<std::array<float, NUM_CARDS>, NUM_CARDS>>();
  957|  10.3M|    for (int r=0; r<NUM_CARDS; r++) (*expected_utilities)[r].fill(0.0f);
  958|       |
  959|   280k|    multiply_2d_arrays_simd(reach_probabilities, inactive_player_range, reach_probabilities);
  960|       |
  961|   280k|    std::array<float, NUM_CARDS> row_reach_sums; row_reach_sums.fill(0.0f);
  962|   280k|    std::array<float, NUM_CARDS> col_reach_sums; col_reach_sums.fill(0.0f);
  963|   280k|    float total_reach = 0.0f;
  964|       |
  965|  10.1M|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  966|   153M|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  967|   143M|            if (!(state.has_card(c1) || state.has_card(c2))) {
  968|   108M|                row_reach_sums[c1 - 1] += reach_probabilities[c1 - 1][c2 - 1];
  969|   108M|                col_reach_sums[c2 - 1] += reach_probabilities[c1 - 1][c2 - 1];
  970|   108M|                total_reach += reach_probabilities[c1 - 1][c2 - 1];
  971|   108M|            }
  972|   143M|        }
  973|  9.87M|    }
  974|       |
  975|   280k|    if (state.is_fold()) {
  976|   110k|        float fold_utility = (state.player == traversing_player) ? state.pot_size * -0.5f : state.pot_size * 0.5f;
  977|  4.05M|        for (int c1=1; c1<=NUM_CARDS; c1++) {
  978|  67.0M|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  979|  63.1M|                if (!(state.has_card(c1) || state.has_card(c2))) {
  980|  47.1M|                    float r = total_reach - row_reach_sums[c1 - 1]
  981|  47.1M|                                          - col_reach_sums[c2 - 1]
  982|  47.1M|                                          + reach_probabilities[c1 - 1][c2 - 1];
  983|  47.1M|                    (*expected_utilities)[c1 - 1][c2 - 1] = fold_utility * r * traversing_player_range[c1 - 1][c2 - 1];
  984|  47.1M|                }
  985|  63.1M|            }
  986|  3.94M|        } 
  987|       |        // std::cout << "FOLD:\n";
  988|       |        // std::cout << state.to_string() << "\n";
  989|       |        // print_opponent_reach_probabilities(*expected_utilities);
  990|       |        // std::cout << "\n";
  991|   110k|        return expected_utilities;
  992|   110k|    }
  993|       |
  994|   169k|    std::unordered_map<int, std::vector<std::tuple<float, int, int>>> strength_map;
  995|       |    
  996|       |    // Prepare all possible hands
  997|  6.24M|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  998|   107M|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  999|   101M|            if (!(state.has_card(c1) || state.has_card(c2))) {
 1000|  72.7M|                GameState new_state = state;
 1001|  72.7M|                new_state.op1 = c1; new_state.op2 = c2;
 1002|  72.7M|                int strength = new_state.best_hand(0);
 1003|       |
 1004|       |                // std::cout << "best_hand_fast:   " << strength << "\n";
 1005|       |                // std::cout << "best_hand normal: " << new_state.best_hand(0) << "\n";
 1006|       |                // std::cout << new_state.to_string() << "\n";
 1007|  72.7M|                float reach = reach_probabilities[c1 - 1][c2 - 1];
 1008|       |
 1009|  72.7M|                strength_map[strength].emplace_back(reach, c1, c2);
 1010|  72.7M|            }
 1011|   101M|        }
 1012|  6.07M|    }
 1013|       |
 1014|   169k|    std::vector<int> sorted_strengths;
 1015|   169k|    sorted_strengths.reserve(strength_map.size());
 1016|       |
 1017|  5.96M|    for (const auto& [strength, _] : strength_map) {
 1018|  5.96M|        sorted_strengths.push_back(strength);
 1019|  5.96M|    }
 1020|       |
 1021|   169k|    std::sort(sorted_strengths.begin(), sorted_strengths.end());
 1022|       |
 1023|   169k|    std::array<float, NUM_CARDS> row_reach_sums_worse;
 1024|   169k|    std::array<float, NUM_CARDS> col_reach_sums_worse; 
 1025|   169k|    std::array<float, NUM_CARDS> row_reach_sums_equal; 
 1026|   169k|    std::array<float, NUM_CARDS> col_reach_sums_equal; 
 1027|       |
 1028|   169k|    fast_initialize_arrays(row_reach_sums_equal, col_reach_sums_equal);
 1029|   169k|    fast_initialize_arrays(row_reach_sums_worse, col_reach_sums_worse);
 1030|       |
 1031|   169k|    float cumulative_reach_probabilities_of_worse = 0.0f;
 1032|   169k|    float cumulative_reach_probabilities_of_equal = 0.0f;
 1033|   169k|    float utility = state.pot_size * 0.5f;
 1034|       |    
 1035|  5.91M|    for (int strength : sorted_strengths) {
 1036|       |        // We've moved to a new hand rank level
 1037|  5.91M|        cumulative_reach_probabilities_of_worse += cumulative_reach_probabilities_of_equal;
 1038|  5.91M|        cumulative_reach_probabilities_of_equal = 0.0f;
 1039|       |
 1040|       |        // row_reach_sums_equal.fill(0.0f);
 1041|       |        // col_reach_sums_equal.fill(0.0f);
 1042|       |
 1043|  5.91M|        fast_initialize_arrays(row_reach_sums_equal, col_reach_sums_equal);
 1044|       |
 1045|  74.0M|        for (const auto& [reach, c1, c2] : strength_map[strength]) {
 1046|  74.0M|            cumulative_reach_probabilities_of_equal += reach;
 1047|  74.0M|            row_reach_sums_equal[c1 - 1] += reach;
 1048|  74.0M|            col_reach_sums_equal[c2 - 1] += reach;
 1049|  74.0M|        }
 1050|       |
 1051|  73.8M|        for (const auto& [reach, c1, c2] : strength_map[strength]) {
 1052|       |
 1053|  73.8M|            float cumulative_reach_probabilities_of_hands_no_overlaps = total_reach - row_reach_sums[c1 - 1] 
 1054|  73.8M|                                                                                    - col_reach_sums[c2 - 1]
 1055|  73.8M|                                                                                    + reach;
 1056|       |            
 1057|  73.8M|            float cumulative_reach_probabilities_of_worse_no_overlaps = cumulative_reach_probabilities_of_worse - row_reach_sums_worse[c1 - 1]
 1058|  73.8M|                                                                                                                - col_reach_sums_worse[c2 - 1];
 1059|       |
 1060|  73.8M|            float cumulative_reach_probabilities_of_equal_no_overlaps = cumulative_reach_probabilities_of_equal - row_reach_sums_equal[c1 - 1]
 1061|  73.8M|                                                                                                                - col_reach_sums_equal[c2 - 1]
 1062|  73.8M|                                                                                                                + reach;
 1063|       |
 1064|  73.8M|            float cumulative_reach_probabilities_of_bettr_no_overlaps = cumulative_reach_probabilities_of_hands_no_overlaps - cumulative_reach_probabilities_of_equal_no_overlaps
 1065|  73.8M|                                                                                                                            - cumulative_reach_probabilities_of_worse_no_overlaps;
 1066|       |
 1067|       |            // std::cout << "hand strength for " << CARD_NAMES[(c1-1)%9] << SUIT_NAMES[(c1-1)/9] << CARD_NAMES[(c2-1)%9] << SUIT_NAMES[(c2-1)/9] << ": " << strength << "\n";
 1068|       |            // std::cout << "cumulative_reach_probabilities_of_worse_no_overlaps for " << CARD_NAMES[(c1-1)%9] << SUIT_NAMES[(c1-1)/9] << CARD_NAMES[(c2-1)%9] << SUIT_NAMES[(c2-1)/9] << ": " << cumulative_reach_probabilities_of_worse_no_overlaps << "\n";
 1069|       |            // std::cout << "cumulative_reach_probabilities_of_equal_no_overlaps for " << CARD_NAMES[(c1-1)%9] << SUIT_NAMES[(c1-1)/9] << CARD_NAMES[(c2-1)%9] << SUIT_NAMES[(c2-1)/9] << ": " << cumulative_reach_probabilities_of_equal_no_overlaps << "\n";
 1070|       |            // std::cout << "cumulative_reach_probabilities_of_bettr_no_overlaps for " << CARD_NAMES[(c1-1)%9] << SUIT_NAMES[(c1-1)/9] << CARD_NAMES[(c2-1)%9] << SUIT_NAMES[(c2-1)/9] << ": " << cumulative_reach_probabilities_of_bettr_no_overlaps << "\n";
 1071|       |            // std::cout << "cumulative_reach_probabilities_of_hands_no_overlaps for " << CARD_NAMES[(c1-1)%9] << SUIT_NAMES[(c1-1)/9] << CARD_NAMES[(c2-1)%9] << SUIT_NAMES[(c2-1)/9] << ": " << cumulative_reach_probabilities_of_hands_no_overlaps << "\n";
 1072|       |            // std::cout << "so expected utility = " << cumulative_reach_probabilities_of_worse_no_overlaps * utility - cumulative_reach_probabilities_of_bettr_no_overlaps * utility << "\n";
 1073|       |            // std::cout << state.to_string() << "\n";
 1074|       |
 1075|  73.8M|            (*expected_utilities)[c1 - 1][c2 - 1] = utility * traversing_player_range[c1 - 1][c2 - 1] * (cumulative_reach_probabilities_of_worse_no_overlaps - cumulative_reach_probabilities_of_bettr_no_overlaps);
 1076|  73.8M|        }
 1077|       |
 1078|  74.0M|        for (const auto& [reach, c1, c2] : strength_map[strength]) {
 1079|  74.0M|            row_reach_sums_worse[c1 - 1] += reach;
 1080|  74.0M|            col_reach_sums_worse[c2 - 1] += reach;
 1081|  74.0M|        }
 1082|  5.91M|    }
 1083|       |
 1084|       |    // std::cout << "FULL EXPECTED UTILITIES:\n";
 1085|       |    // std::cout << state.to_string() << "\n";
 1086|       |    // print_opponent_reach_probabilities(*expected_utilities);
 1087|       |    // std::cout << "\n";
 1088|       |
 1089|   169k|    return expected_utilities;
 1090|   280k|}

/Users/glen/cfr/shortdecknoluckupdate/src/game_state.cpp:
    1|       |#include "game_state.h"
    2|       |#include "cfr.h"
    3|       |
    4|       |GameState::GameState(): player(false),
    5|       |                        op1(0), 
    6|       |                        op2(0), 
    7|       |                        ip1(0), 
    8|       |                        ip2(0),
    9|       |                        fp1(0), 
   10|       |                        fp2(0),
   11|       |                        fp3(0), 
   12|       |                        trn(0), 
   13|       |                        rvr(0), 
   14|       |                        pfp_history(0),
   15|       |                        flp_history(0),
   16|       |                        trn_history(0),
   17|       |                        rvr_history(0),
   18|       |                        flp_seen(false), 
   19|       |                        trn_seen(false),
   20|       |                        rvr_seen(false),
   21|       |                        is_terminal(false),
   22|       |                        pot_size(0.0f) 
   23|     59|{
   24|     59|    bets.push(0.0f);
   25|     59|} 
   26|       |
   27|      7|std::string GameState::to_string(bool verbose) const {
   28|      7|    std::stringstream ss;
   29|       |    
   30|       |    // OOP player cards
   31|      7|    ss << "OOP cards:    ";
   32|      7|    if (op1 != 0 && op2 != 0) ss << CARD_NAMES[rank(op1)] << SUIT_NAMES[suit(op1)] << CARD_NAMES[rank(op2)] << SUIT_NAMES[suit(op2)];
   33|       |
   34|       |    // IP player cards
   35|      7|    ss << "\nIP cards:     ";
   36|      7|    if (ip1 != 0 && ip2 != 0) ss << CARD_NAMES[rank(ip1)] << SUIT_NAMES[suit(ip1)] << CARD_NAMES[rank(ip2)] << SUIT_NAMES[suit(ip2)];
   37|       |
   38|       |    // Flop cards
   39|      7|    ss << "\nFlop cards:   ";
   40|      7|    if (flp_seen) ss << CARD_NAMES[rank(fp1)] << SUIT_NAMES[suit(fp1)] << CARD_NAMES[rank(fp2)] << SUIT_NAMES[suit(fp2)]
   41|      7|                                                                                         << CARD_NAMES[rank(fp3)] << SUIT_NAMES[suit(fp3)];
   42|       |
   43|       |    // Turn
   44|      7|    ss << "\nTurn card:    ";
   45|      7|    if (trn_seen) ss << CARD_NAMES[rank(trn)] << SUIT_NAMES[suit(trn)];
   46|       |    
   47|       |    // River
   48|      7|    ss << "\nRiver card:   ";
   49|      7|    if (rvr_seen) ss << CARD_NAMES[rank(rvr)] << SUIT_NAMES[suit(rvr)];
   50|       |
   51|      7|    if (verbose) {
   52|       |        // To be implemented
   53|      0|        return ss.str();
   54|      7|    } else {
   55|      7|        std::bitset<32> binary_pfp_history(pfp_history);
   56|      7|        std::bitset<32> binary_flp_history(flp_history);
   57|      7|        std::bitset<32> binary_trn_history(trn_history);
   58|      7|        std::bitset<32> binary_rvr_history(rvr_history);
   59|      7|        ss << "\nPflp history: " << binary_pfp_history << "\n";
   60|      7|        if (flp_seen) ss << "Flop history: " << binary_flp_history << "\n";
   61|      7|        if (trn_seen) ss << "Turn history: " << binary_trn_history << "\n";
   62|      7|        if (rvr_seen) ss << "Rivr history: " << binary_rvr_history << "\n";
   63|      7|    }
   64|       |
   65|      7|    std::stack<float> temp = bets;
   66|       |    
   67|      7|    ss << "Player:       " << player << "\n";
   68|       |    // ss << "Biggest_bet:  " << temp.top() << "\n";
   69|       |    // temp.pop();
   70|       |    // if (!temp.empty()) ss << "Mutual_bet:   " << temp.top() << "\n";
   71|       |
   72|      7|    ss << "Bets:         " << stack_to_string(bets) << "\n";
   73|       |
   74|      7|    ss << "Pot_size:     " << pot_size << "\n";
   75|      7|    ss << "Num_actions:  " << num_actions() << "\n";
   76|      7|    ss << "Is_terminal:  " << is_terminal << "\n";
   77|       |    
   78|      7|    return ss.str();
   79|      7|}
   80|       |
   81|      0|bool GameState::operator==(const GameState& other) const {
   82|      0|    return player == other.player &&
   83|      0|           op1 == other.op1 && 
   84|      0|           op2 == other.op2 && 
   85|      0|           ip1 == other.ip1 && 
   86|      0|           ip2 == other.ip2 &&
   87|      0|           fp1 == other.fp1 &&
   88|      0|           fp2 == other.fp2 &&
   89|      0|           fp3 == other.fp3 &&
   90|      0|           trn == other.trn &&
   91|      0|           rvr == other.rvr &&
   92|      0|           pfp_history == other.pfp_history &&
   93|      0|           flp_history == other.flp_history &&
   94|      0|           trn_history == other.trn_history &&
   95|      0|           rvr_history == other.rvr_history &&
   96|      0|           pot_size == other.pot_size &&
   97|      0|           flp_seen == other.flp_seen &&
   98|      0|           trn_seen == other.trn_seen &&
   99|      0|           rvr_seen == other.rvr_seen;
  100|      0|}
  101|       |
  102|   179k|bool GameState::is_chance() const {
  103|       |    //  Flop
  104|   179k|    if ((!flp_seen) && 
  105|   179k|       ((pfp_history == 0b111001) || (((pfp_history & 0b111) == 0b111) && ((pfp_history != 0b111)))))
  106|      0|        return true;
  107|       |
  108|       |    //  Turn
  109|   179k|    if ((!trn_seen) &&
  110|   179k|       (((flp_history & 0b111) == 0b111) || ((flp_history & 0b111111) == 0b1001))) // no turn, but flop is done
  111|      0|        return true;
  112|       |
  113|       |    //  River
  114|   179k|    if ((!rvr_seen) &&
  115|   179k|       (((trn_history & 0b111) == 0b111) || ((trn_history & 0b111111) == 0b1001))) // no river, but turn is done
  116|  1.97k|        return true;
  117|       |
  118|       |    //  All-in, call
  119|   177k|    if (!is_terminal && 
  120|   177k|       (((pfp_history & 0b111111) == 0b110111) || 
  121|   175k|        ((flp_history & 0b111111) == 0b110111) ||
  122|   175k|        ((trn_history & 0b111111) == 0b110111)))
  123|      0|        return true;
  124|       |
  125|   177k|    return false;
  126|   177k|}
  127|       |
  128|  61.9M|int GameState::best_hand(bool p) const {
  129|  61.9M|    std::array<uint16_t, 4> suits = {0, 0, 0, 0};
  130|       |    
  131|  18.4E|    uint8_t c1 = (p==0) ? op1 : ip1;
  132|  18.4E|    uint8_t c2 = (p==0) ? op2 : ip2;
  133|       |
  134|  61.9M|    suits[suit(c1)] |= (1U << rank(c1));
  135|  61.9M|    suits[suit(c2)] |= (1U << rank(c2));
  136|       |
  137|  64.1M|    if (fp1 > 0) suits[suit(fp1)] |= (1U << rank(fp1));
  138|  66.0M|    if (fp2 > 0) suits[suit(fp2)] |= (1U << rank(fp2));
  139|  67.5M|    if (fp3 > 0) suits[suit(fp3)] |= (1U << rank(fp3));
  140|       |
  141|  66.6M|    if (trn > 0) suits[suit(trn)] |= (1U << rank(trn));
  142|  65.3M|    if (rvr > 0) suits[suit(rvr)] |= (1U << rank(rvr));
  143|       |
  144|       |    /************************* Straight flush *************************/
  145|       |
  146|   441M|    for (int i=0; i<6; i++) {
  147|   379M|        if (((suits[0] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i]) ||
  148|   412M|            ((suits[1] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i]) ||
  149|   416M|            ((suits[2] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i]) || 
  150|   420M|            ((suits[3] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i])) {
  151|  16.2k|            return 900000 + (6-i)*10000;
  152|  16.2k|        }
  153|   379M|    }
  154|       |
  155|       |    /************************* Four of a kind *************************/
  156|       |    
  157|  61.9M|    int best = -1;
  158|  61.9M|    int kicker = -1;
  159|       |
  160|   662M|    for (int i=0; i<9; i++) {
  161|   600M|        if ((suits[0] & SINGLE_MASKS[i]) && 
  162|   600M|            (suits[1] & SINGLE_MASKS[i]) &&
  163|   600M|            (suits[2] & SINGLE_MASKS[i]) &&
  164|   600M|            (suits[3] & SINGLE_MASKS[i])) {
  165|   518k|            best = 9-i;
  166|  2.39M|            for (int k=0; k<9; k++) {
  167|  2.39M|                if ((k != i) && 
  168|  2.39M|                    ((suits[0] & SINGLE_MASKS[k]) || 
  169|  2.04M|                     (suits[1] & SINGLE_MASKS[k]) ||
  170|  2.04M|                     (suits[2] & SINGLE_MASKS[k]) ||
  171|  2.04M|                     (suits[3] & SINGLE_MASKS[k]))) {
  172|   518k|                    kicker = 9-k;
  173|   518k|                    break;
  174|   518k|                }
  175|  2.39M|            }
  176|   518k|        }
  177|   600M|    }
  178|       |
  179|  61.9M|    if (kicker != -1 && best != -1) return 800000 + best*10000 + kicker*1000;
  180|       |
  181|       |    /************************* Flush *************************/
  182|       |    
  183|  61.4M|    best = -1;
  184|       |
  185|   334M|    for (int i=0; i<4; i++) {
  186|   273M|        if (__builtin_popcount(suits[i]) >= 5) {
  187|       |            // find highest card in the flush
  188|  1.00M|            for (int k=0; k<9; k++) {
  189|  1.00M|                if (suits[i] & SINGLE_MASKS[k]) {
  190|   548k|                    best = 9-k;
  191|   548k|                    break;
  192|   548k|                }
  193|  1.00M|            }
  194|   548k|        }
  195|   273M|    }
  196|       |
  197|  61.4M|    if (best != -1) return 700000 + best*10000;
  198|       |
  199|       |    /************************* Full House *************************/
  200|       |
  201|  60.8M|    int trips = -1;
  202|  60.8M|    int pair = -1;
  203|       |
  204|       |    // Find highest trips
  205|   565M|    for (int i=0; i<9; i++) {
  206|   521M|        int count = ((suits[0] & SINGLE_MASKS[i]) ? 1 : 0) +
  207|   521M|                    ((suits[1] & SINGLE_MASKS[i]) ? 1 : 0) +
  208|   521M|                    ((suits[2] & SINGLE_MASKS[i]) ? 1 : 0) +
  209|   521M|                    ((suits[3] & SINGLE_MASKS[i]) ? 1 : 0);
  210|   521M|        if (count >= 3) {
  211|  16.3M|            trips = 9-i;
  212|  16.3M|            break;
  213|  16.3M|        }
  214|   521M|    }
  215|       |
  216|       |    // Find highest pair
  217|  60.8M|    if (trips != -1) {
  218|   124M|        for (int i=0; i<9; i++) {
  219|   117M|            if ((9-i) == trips) continue; // skip trips we already found
  220|   104M|            int count = ((suits[0] & SINGLE_MASKS[i]) ? 1 : 0) +
  221|   104M|                        ((suits[1] & SINGLE_MASKS[i]) ? 1 : 0) +
  222|   104M|                        ((suits[2] & SINGLE_MASKS[i]) ? 1 : 0) +
  223|   104M|                        ((suits[3] & SINGLE_MASKS[i]) ? 1 : 0);
  224|   104M|            if (count >= 2) {
  225|  9.05M|                pair = 9-i;
  226|  9.05M|                break;
  227|  9.05M|            }
  228|   104M|        }
  229|  16.3M|    }
  230|       |
  231|  60.8M|    if (pair != -1 && trips != -1) return 600000 + trips*10000 + pair*1000;
  232|       |
  233|       |    /************************* Straight *************************/
  234|       |
  235|  51.8M|    uint16_t all_cards = suits[0] | suits[1] | suits[2] | suits[3];
  236|       |
  237|   401M|    for (int i=0; i<6; i++) {
  238|   353M|        if ((all_cards & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i]) {
  239|  3.03M|            return 500000 + (6-i)*10000;
  240|  3.03M|        }
  241|   353M|    }
  242|       |
  243|       |    /************************* Three of a kind *************************/
  244|       |
  245|  48.7M|    trips = -1;
  246|  48.7M|    int kicker1 = -1;
  247|  48.7M|    int kicker2 = -1;
  248|       |
  249|       |    // Find highest trips
  250|   507M|    for (int i=0; i<9; i++) {
  251|   466M|        int count = ((suits[0] & SINGLE_MASKS[i]) ? 1 : 0) +
  252|   466M|                    ((suits[1] & SINGLE_MASKS[i]) ? 1 : 0) +
  253|   466M|                    ((suits[2] & SINGLE_MASKS[i]) ? 1 : 0) +
  254|   466M|                    ((suits[3] & SINGLE_MASKS[i]) ? 1 : 0);
  255|   466M|        if (count >= 3) {
  256|  7.59M|            trips = 9-i;
  257|  7.59M|            break;
  258|  7.59M|        }
  259|   466M|    }
  260|       |
  261|       |    // Find highest kickers
  262|  48.7M|    if (trips != -1) {
  263|  42.2M|        for (int i=0; i<9; i++) {
  264|  42.2M|            if ((9-i) == trips) continue; // skip trips we already found
  265|  35.1M|            if (all_cards & SINGLE_MASKS[i]) {
  266|  15.1M|                if (kicker1 == -1) {
  267|  7.59M|                    kicker1 = 9-i;
  268|  7.59M|                } else if (kicker2 == -1) {
  269|  7.58M|                    kicker2 = 9-i;
  270|  7.58M|                    break;
  271|  7.58M|                }
  272|  15.1M|            }
  273|  35.1M|        }
  274|  7.59M|    }
  275|       |
  276|  48.7M|    if (kicker2 != -1 && kicker1 != -1 && trips != -1) {
  277|  7.58M|        return 400000 + trips*10000 + kicker1*1000 + kicker2*100;
  278|  7.58M|    }
  279|       |
  280|       |    /************************* Two Pair *************************/
  281|       |
  282|  41.2M|    int pair1 = -1;
  283|  41.2M|    int pair2 = -1;
  284|  41.2M|    kicker = -1;
  285|       |
  286|       |    // Find highest pairs
  287|   369M|    for (int i=0; i<9; i++) {
  288|   367M|        int count = ((suits[0] & SINGLE_MASKS[i]) ? 1 : 0) +
  289|   367M|                    ((suits[1] & SINGLE_MASKS[i]) ? 1 : 0) +
  290|   367M|                    ((suits[2] & SINGLE_MASKS[i]) ? 1 : 0) +
  291|   367M|                    ((suits[3] & SINGLE_MASKS[i]) ? 1 : 0);
  292|   367M|        if (count >= 2) {
  293|  88.2M|            if (pair1==-1) {
  294|  52.0M|                pair1 = 9-i;
  295|  52.0M|            } else if (pair2==-1) {
  296|  39.5M|                pair2 = 9-i;
  297|  39.5M|                break;
  298|  39.5M|            }
  299|  88.2M|        }
  300|   367M|    }    
  301|       |
  302|       |    // Find best kicker
  303|  55.1M|    if (pair1 != -1 && pair2 != -1) {
  304|   139M|        for (int i=0; i<9; i++) {
  305|   138M|            if (((9-i)!=pair1) && ((9-i)!=pair2)) {
  306|   112M|                if (all_cards & SINGLE_MASKS[i]) {
  307|  38.5M|                    kicker = 9-i;
  308|  38.5M|                    break;
  309|  38.5M|                }
  310|   112M|            }
  311|   138M|        }
  312|  39.5M|    }
  313|       |
  314|  41.2M|    if (kicker != -1 && pair2 != -1 && pair1 != -1) {
  315|  38.5M|        return 300000 + pair1*10000 + pair2*1000 + kicker*100;
  316|  38.5M|    }
  317|       |
  318|       |    /************************* Pair *************************/
  319|       |
  320|  2.60M|    pair = -1;
  321|  2.60M|    kicker1 = -1;
  322|  2.60M|    kicker2 = -1;
  323|  2.60M|    int kicker3 = -1;
  324|       |
  325|       |    // Find highest pair
  326|  50.7M|    for (int i=0; i<9; i++) {
  327|  50.7M|        int count = ((suits[0] & SINGLE_MASKS[i]) ? 1 : 0) +
  328|  50.7M|                    ((suits[1] & SINGLE_MASKS[i]) ? 1 : 0) +
  329|  50.7M|                    ((suits[2] & SINGLE_MASKS[i]) ? 1 : 0) +
  330|  50.7M|                    ((suits[3] & SINGLE_MASKS[i]) ? 1 : 0);
  331|  50.7M|        if (count >= 2) {
  332|  16.8M|            pair = 9-i;
  333|  16.8M|            break;
  334|  16.8M|        }
  335|  50.7M|    }    
  336|       |
  337|       |    // Find best kickers
  338|  16.8M|    if (pair != -1) {
  339|   102M|        for (int i=0; i<9; i++) {
  340|   102M|            if ((9-i) == pair) continue;
  341|  85.7M|            if (all_cards & SINGLE_MASKS[i]) {
  342|  50.1M|                if (kicker1 == -1) {
  343|  16.8M|                    kicker1 = 9-i;
  344|  33.3M|                } else if (kicker2 == -1) {
  345|  16.7M|                    kicker2 = 9-i;
  346|  16.7M|                } else if (kicker3 == -1) {
  347|  16.7M|                    kicker3 = 9-i;
  348|  16.7M|                    break;
  349|  16.7M|                }
  350|  50.1M|            }
  351|  85.7M|        }
  352|  16.8M|    }
  353|       |
  354|  16.7M|    if (kicker3 != -1 && kicker2 != -1 && kicker1 != -1 && pair != -1) {
  355|  16.7M|        return 200000 + pair*10000 + kicker1*1000 + kicker2*100 + kicker3*10;
  356|  16.7M|    }
  357|       |
  358|       |    /************************* High Card *************************/
  359|       |
  360|  18.4E|    kicker1 = -1;
  361|  18.4E|    kicker2 = -1;
  362|  18.4E|    kicker3 = -1;
  363|  18.4E|    int kicker4 = -1;
  364|  18.4E|    int kicker5 = -1;
  365|       |
  366|       |    // Find best kickers
  367|  18.4E|    for (int i=0; i<9; i++) {
  368|      0|        if (all_cards & SINGLE_MASKS[i]) {
  369|      0|            if (kicker1 == -1) {
  370|      0|                kicker1 = 9-i;
  371|      0|            } else if (kicker2 == -1) {
  372|      0|                kicker2 = 9-i;
  373|      0|            } else if (kicker3 == -1) {
  374|      0|                kicker3 = 9-i;
  375|      0|            } else if (kicker4 == -1) {
  376|      0|                kicker4 = 9-i;
  377|      0|            } else if (kicker5 == -1) {
  378|      0|                kicker5 = 9-i;
  379|      0|                break;
  380|      0|            }
  381|      0|        }
  382|      0|    }
  383|       |
  384|  18.4E|    if (kicker1 != -1 && kicker2 != -1 && kicker3 != -1 && kicker4 != -1 && kicker5 != -1) {
  385|      0|        return 100000 + kicker1*10000 + kicker2*1000 + kicker3*100 + kicker4*10 + kicker5;
  386|      0|    }
  387|       |
  388|  18.4E|    std::cout << "ERROR: NO BEST HAND\n";
  389|       |
  390|  18.4E|    return -1;
  391|  18.4E|}
  392|       |
  393|      0|float GameState::showdown(bool p) const {
  394|      0|    int p_best = best_hand(p);
  395|      0|    int o_best = best_hand(!p);
  396|       |
  397|      0|    if (p_best == o_best) return 0.0f;
  398|       |
  399|      0|    return (p_best > o_best) ? pot_size * 0.5f : pot_size * -0.5f;
  400|      0|}
  401|       |
  402|      0|float GameState::utility(bool p) const {
  403|       |    // Preflop fold
  404|      0|    if (((pfp_history & 0b111) == 0b1) &&
  405|      0|         (pfp_history != 0b111001)) return (p == player) ? -0.5f * pot_size : 0.5f * pot_size;
  406|       |
  407|       |    // Fold on flop
  408|      0|    if (((flp_history & 0b111) == 0b1) &&
  409|      0|        (flp_history != 0b1001) &&
  410|      0|        (flp_history != 0b1))
  411|      0|        return (p == player) ? -0.5f * pot_size : 0.5f * pot_size;
  412|       |
  413|       |    // Fold on turn
  414|      0|    if (((trn_history & 0b111) == 0b1) &&
  415|      0|        (trn_history != 0b1001) &&
  416|      0|        (trn_history != 0b1))
  417|      0|        return (p == player) ? -0.5f * pot_size : 0.5f * pot_size;
  418|       |
  419|       |    // Fold on river
  420|      0|    if (((rvr_history & 0b111) == 0b1) &&
  421|      0|        (rvr_history != 0b1001) &&
  422|      0|        (rvr_history != 0b1))
  423|      0|        return (p == player) ? -0.5f * pot_size : 0.5f * pot_size;
  424|       |
  425|       |    // Check check on river
  426|      0|    if ((rvr_history & 0b111111) == 0b1001) return showdown(p);
  427|       |
  428|       |    // Call on river
  429|      0|    if ((rvr_history & 0b111) == 0b111) return showdown(p);
  430|       |
  431|       |    // All ins
  432|      0|    if (((pfp_history & 0b111111) == 0b110111) || 
  433|      0|        ((flp_history & 0b111111) == 0b110111) ||
  434|      0|        ((trn_history & 0b111111) == 0b110111))
  435|      0|        return showdown(p);
  436|       |
  437|      0|    return -1;
  438|      0|}
  439|       |
  440|   285k|bool GameState::is_fold() const {
  441|       |    // Preflop fold
  442|   285k|    if (((pfp_history & 0b111) == 0b1) &&
  443|   285k|         (pfp_history != 0b111001)) return true;
  444|       |
  445|       |    // Fold on flop
  446|   285k|    if (((flp_history & 0b111) == 0b1) &&
  447|   285k|        (flp_history != 0b1001) &&
  448|   285k|        (flp_history != 0b1))
  449|      0|        return true;
  450|       |
  451|       |    // Fold on turn
  452|   285k|    if (((trn_history & 0b111) == 0b1) &&
  453|   285k|        (trn_history != 0b1001) &&
  454|   285k|        (trn_history != 0b1))
  455|  1.83k|        return true;
  456|       |
  457|       |    // Fold on river
  458|   283k|    if (((rvr_history & 0b111) == 0b1) &&
  459|   283k|        (rvr_history != 0b1001) &&
  460|   283k|        (rvr_history != 0b1))
  461|   110k|        return true;
  462|       |    
  463|   172k|    return false;
  464|   283k|}
  465|       |
  466|   789k|int GameState::num_actions() const {
  467|       |
  468|   789k|    if (pot_size / 2.0f + bets.top() == STACK_SIZE) return 2;
  469|       |    
  470|       |    /************************* Preflop *************************/
  471|       |
  472|   531k|    if (pfp_history == 0) return 7; // open; can do anything 1-7
  473|       |    
  474|   531k|    if (pfp_history == 0b111) return 6; // call; can check or bet any size 1-6
  475|       |    
  476|   531k|    if (((pfp_history & 0b111) == 0b110) && // all-in; must fold or call
  477|   531k|         (!flp_seen))
  478|      0|         return 2;
  479|       |    
  480|   531k|    if ((pfp_history < 0b1000000000) && // responding to raise; respond 1-7
  481|   531k|        (!flp_seen)) {
  482|       |        // raise
  483|      0|        int i=0;
  484|      0|        while ((i < 4) && (pot_size / 2.0f + bets.top() * RAISE_SIZES[i]) < STACK_SIZE) i++;
  485|       |        // 4-i is number of forbidden actions
  486|      0|        return 7-(4-i);
  487|      0|    } 
  488|       |    
  489|   531k|    if ((pfp_history > 0b1000000000) && // bet/raise but at limit; 1 or 7
  490|   531k|        (pfp_history < 0b1111111111111) &&
  491|   531k|        (!flp_seen))
  492|      0|        return 2; 
  493|       |
  494|       |    /************************* Flop *************************/
  495|       |
  496|   531k|    if ((flp_history == 0) || (flp_history == 1)) {
  497|      0|        int i=0;
  498|      0|        while ((i < 4) && (pot_size / 2.0f + pot_size * BET_SIZES[i]) < STACK_SIZE) i++;
  499|      0|        return 6-(4-i); // 6 b/c you can't call
  500|      0|    }
  501|       |    
  502|   531k|    if (((flp_history & 0b111) == 0b110) && // all-in; must fold or call
  503|   531k|         (!trn_seen)) 
  504|      0|         return 2; 
  505|       |    
  506|   531k|    if ((flp_history < 0b1000000000) && // responding to raise; respond 1-7
  507|   531k|        (!trn_seen)) {
  508|       |        // raise
  509|      0|        int i=0;
  510|      0|        while ((i < 4) && (pot_size / 2.0f + bets.top() * RAISE_SIZES[i]) < STACK_SIZE) i++;
  511|      0|        return 7-(4-i);
  512|      0|    }
  513|       |        
  514|       |    
  515|   531k|    if ((flp_history > 0b1000000000) && // bet/raise but at limit; call or fold
  516|   531k|        (flp_history < 0b1111111111111) &&
  517|   531k|        (!trn_seen))
  518|      0|        return 2;
  519|       |
  520|       |    /************************* Turn *************************/
  521|       |
  522|   531k|    if ((trn_history == 0) || (trn_history == 1)) { // open action; can do anything 1-7; overlap all-ins
  523|  1.96k|        int i=0;
  524|  7.87k|        while ((i < 4) && (pot_size / 2.0f + pot_size * BET_SIZES[i]) < STACK_SIZE) i++;
  525|  1.96k|        return 6-(4-i);
  526|  1.96k|    } 
  527|       |    
  528|   529k|    if (((trn_history & 0b111) == 0b110) && // all-in; must fold or call
  529|   529k|         (!rvr_seen)) 
  530|      0|         return 2;
  531|       |    
  532|   529k|    if ((trn_history < 0b1000000000) && // responding to raise; respond 1-7
  533|   529k|        (!rvr_seen)) {
  534|  23.0k|        int i=0;
  535|  42.0k|        while ((i < 4) && (pot_size / 2.0f + bets.top() * RAISE_SIZES[i]) < STACK_SIZE) i++;
  536|  23.0k|        return 7-(4-i);
  537|  23.0k|    }
  538|       |        
  539|   506k|    if ((trn_history > 0b1000000000) && // bet/raise but at limit; call or fold
  540|   506k|        (trn_history < 0b1111111111111) &&
  541|   506k|        (!rvr_seen))
  542|      6|        return 2;
  543|       |
  544|       |    /************************* River *************************/
  545|       |
  546|   506k|    if ((rvr_history == 0) || (rvr_history == 1)) { // open action / check; can do anything 1-7; overlap all-ins
  547|   323k|        int i=0;
  548|   510k|        while ((i < 4) && (pot_size / 2.0f + pot_size * BET_SIZES[i]) < STACK_SIZE) i++;
  549|   323k|        return 6-(4-i);
  550|   323k|    }
  551|       |    
  552|   182k|    if ((rvr_history & 0b111) == 0b110) // all-in; must fold or call 
  553|      0|        return 2; 
  554|       |    
  555|   182k|    if (rvr_history < 0b1000000000) { // bet/raise; respond 1-7
  556|   182k|        int i=0;
  557|   239k|        while ((i < 4) && (pot_size / 2.0f + bets.top() * RAISE_SIZES[i]) < STACK_SIZE) i++;
  558|   182k|        return 7-(4-i);
  559|   182k|    }
  560|       |
  561|    111|    if ((rvr_history > 0b1000000000) && // bet/raise but at limit; call or fold
  562|    384|        (rvr_history < 0b1111111111111))
  563|    384|        return 2;
  564|       |    
  565|  18.4E|    return 0;
  566|    111|}
  567|       |
  568|  1.93k|int GameState::num_in_deck() const {
  569|  1.93k|    int res = 0;
  570|       |    
  571|  1.93k|    if (op1 != 0) res++;
  572|  1.93k|    if (op2 != 0) res++;
  573|  1.93k|    if (ip1 != 0) res++;
  574|  1.93k|    if (ip2 != 0) res++;
  575|  1.93k|    if (fp1 != 0) res++;
  576|  1.93k|    if (fp2 != 0) res++;
  577|  1.93k|    if (fp3 != 0) res++;
  578|  1.93k|    if (trn != 0) res++;
  579|  1.93k|    if (rvr != 0) res++;
  580|       |
  581|  1.93k|    return NUM_CARDS-res;
  582|  1.93k|}
  583|       |
  584|   415k|int GameState::index_to_action(int index) const {
  585|       |
  586|   415k|    if (pot_size / 2.0f + bets.top() == STACK_SIZE) return (index == 0) ? 1 : 7;
  587|       |    
  588|       |    /************************* Preflop *************************/
  589|       |    
  590|   241k|    if (pfp_history == 0) return index+1; // open; can do anything 1-7
  591|       |    
  592|   241k|    if (pfp_history == 0b111) return index+1; // call; can check or bet any size 1-6
  593|       |    
  594|   241k|    if (((pfp_history & 0b111) == 0b110) && // all-in; must fold or call
  595|   241k|         (!flp_seen)) 
  596|      0|        return (index == 0) ? 1 : 7;
  597|       |    
  598|   241k|    if ((pfp_history < 0b1000000000) && // bet/raise; respond 1-7
  599|   241k|        (!flp_seen)) {
  600|      0|        int num = num_actions();
  601|      0|        int num_banned = 7-num;
  602|       |
  603|      0|        if (index <= 4-num_banned) return index+1;
  604|      0|        if (index >  4-num_banned) return index+num_banned+1;
  605|      0|    }
  606|       |    
  607|   241k|    if ((pfp_history > 0b1000000000) && // bet/raise but at limit; 1 or 7
  608|   241k|        (pfp_history < 0b1111111111111) &&
  609|   241k|        (!flp_seen))
  610|      0|        return (index == 0) ? 1 : 7; 
  611|       |
  612|       |    /************************* Flop *************************/
  613|       |    
  614|   241k|    if ((flp_history == 0) || (flp_history == 1)) {
  615|      0|        int num = num_actions();
  616|      0|        int num_banned = 6-num;
  617|       |
  618|      0|        if (index <= 4-num_banned) return index+1;
  619|      0|        if (index >  4-num_banned) return index+num_banned+1;
  620|      0|    } 
  621|       |    
  622|   241k|    if (((flp_history & 0b111) == 0b110) && // all-in; must fold or call
  623|   241k|         (!trn_seen)) 
  624|      0|        return (index == 0) ? 1 : 7;
  625|       |    
  626|   241k|    if ((flp_history < 0b1000000000) && // bet/raise; respond 1-7
  627|   241k|        (!trn_seen)) {
  628|      0|        int num = num_actions();
  629|      0|        int num_banned = 7-num;
  630|       |
  631|      0|        if (index <= 4-num_banned) return index+1;
  632|      0|        if (index >  4-num_banned) return index+num_banned+1;
  633|      0|    } 
  634|       |    
  635|   241k|    if ((flp_history > 0b1000000000) && // bet/raise but at limit; call or fold
  636|   241k|        (flp_history < 0b1111111111111) &&
  637|   241k|        (!trn_seen))
  638|      0|        return (index == 0) ? 1 : 7;
  639|       |
  640|       |    /************************* Turn *************************/
  641|       |    
  642|   241k|    if ((trn_history == 0) || (trn_history == 1)) {
  643|  1.05k|        int num = num_actions();
  644|  1.05k|        int num_banned = 6-num;
  645|       |
  646|  1.05k|        if (index <= 4-num_banned) return index+1;
  647|    206|        if (index >  4-num_banned) return index+num_banned+1;
  648|    206|    }
  649|       |    
  650|   240k|    if (((trn_history & 0b111) == 0b110) && // all-in; must fold or call
  651|   240k|         (!rvr_seen)) 
  652|      0|        return (index == 0) ? 1 : 7;
  653|       |    
  654|   240k|    if ((trn_history < 0b1000000000) && // bet/raise; respond 1-7
  655|   240k|        (!rvr_seen)) {
  656|  16.5k|        int num = num_actions();
  657|  16.5k|        int num_banned = 7-num;
  658|       |
  659|  16.5k|        if (index <= 4-num_banned) return index+1;
  660|  9.09k|        if (index >  4-num_banned) return index+num_banned+1;
  661|  9.09k|    }
  662|       |    
  663|   223k|    if ((trn_history > 0b1000000000) && // bet/raise but at limit; call or fold
  664|   223k|        (trn_history < 0b1111111111111) &&
  665|   223k|        (!rvr_seen))
  666|      0|        return (index == 0) ? 1 : 7;
  667|       |
  668|       |    /************************* River *************************/
  669|       |
  670|   223k|    if ((rvr_history == 0) || (rvr_history == 1)) {
  671|   138k|        int num = num_actions();
  672|   138k|        int num_banned = 6-num;
  673|       |
  674|   138k|        if (index <= 4-num_banned) return index+1;
  675|  59.3k|        if (index >  4-num_banned) return index+num_banned+1;
  676|  59.3k|    }  
  677|       |    
  678|  85.6k|    if ((rvr_history & 0b111) == 0b110) // all-in; must fold or call 
  679|      0|        return (index == 0) ? 1 : 7;
  680|       |    
  681|  85.6k|    if (rvr_history < 0b1000000000) {
  682|  85.6k|        int num = num_actions();
  683|  85.6k|        int num_banned = 7-num;
  684|       |
  685|  85.6k|        if (index <= 4-num_banned) return index+1;
  686|  52.7k|        if (index >  4-num_banned) return index+num_banned+1;
  687|  52.7k|    }
  688|       |    
  689|  18.4E|    if ((rvr_history > 0b1000000000) && // bet/raise but at limit; call or fold
  690|  18.4E|        (rvr_history < 0b1111111111111))
  691|      0|        return (index == 0) ? 1 : 7;
  692|       |
  693|  18.4E|    return 0;
  694|  18.4E|}
  695|       |
  696|  3.47k|int GameState::action_to_index(int action) const {
  697|  13.9k|    for (uint8_t i=0; i<7; i++) {
  698|  13.9k|        if (index_to_action(i) == action) {
  699|  3.47k|            return i;
  700|  3.47k|        }
  701|  13.9k|    }
  702|      0|    return 0;
  703|  3.47k|}
  704|       |
  705|   401k|void GameState::apply_index(int index) {
  706|       |
  707|   401k|    uint8_t a = index_to_action(index);
  708|       |
  709|   401k|    player = !player; // player alternates
  710|       |
  711|   401k|    if (a == 7) { // call
  712|   113k|        bets.push(bets.top());
  713|   113k|        pot_size += 2.0f * bets.top();
  714|   113k|        if (rvr_seen) is_terminal = true;
  715|   113k|    }
  716|       |   
  717|   287k|    else if ((a >= 2) && (a <= 5)) {
  718|  27.1k|        if (bets.top() == 0.0f) {
  719|       |            // bet
  720|  20.4k|            bets.push(pot_size * BET_SIZES[a-2]);
  721|  20.4k|        } else {
  722|       |            // raise
  723|  6.79k|            bets.push(bets.top() * RAISE_SIZES[a-2]);
  724|  6.79k|        }
  725|  27.1k|    }
  726|       |
  727|   260k|    else if (a == 6) bets.push(STACK_SIZE - (pot_size / 2.0f));
  728|       |
  729|   173k|    else if (a == 1) {
  730|   173k|        if (!flp_seen) {
  731|      0|            if ((pfp_history != 0b111)) { // can't be a check. must be fold
  732|      0|                float unmatched_bet = bets.top();
  733|      0|                bets.pop();
  734|      0|                pot_size += 2.0f * bets.top(); // this is the biggest mutual bet
  735|      0|                bets.push(unmatched_bet); // preserve bets for printing purposes
  736|      0|                player = !player;
  737|      0|                is_terminal = true;
  738|      0|                bets.push(0.0f);
  739|      0|            } else {
  740|      0|                bets.push(0.0f); // check. pushing this will make it easier to undo actions
  741|      0|            }
  742|   173k|        } else if (!trn_seen) {
  743|      0|            if ((flp_history != 0) && (flp_history != 0b1)) { // not check or check-check. must be a fold
  744|      0|                float unmatched_bet = bets.top();
  745|      0|                bets.pop();
  746|      0|                pot_size += 2.0f * bets.top();
  747|      0|                bets.push(unmatched_bet);
  748|      0|                player = !player;
  749|      0|                is_terminal = true;
  750|      0|                bets.push(0.0f);
  751|      0|            } else {
  752|      0|                bets.push(0.0f);
  753|      0|            }
  754|   173k|        } else if (!rvr_seen) {
  755|  2.06k|            if ((trn_history != 0) && (trn_history != 0b1)) {
  756|  1.85k|                float unmatched_bet = bets.top();
  757|  1.85k|                bets.pop();
  758|  1.85k|                pot_size += 2.0f * bets.top();
  759|  1.85k|                bets.push(unmatched_bet);
  760|  1.85k|                player = !player;
  761|  1.85k|                is_terminal = true;
  762|  1.85k|                bets.push(0.0f);
  763|  1.85k|            } else {
  764|    206|                bets.push(0.0f);
  765|    206|            }
  766|   171k|        } else {
  767|   171k|            if ((rvr_history != 0) && (rvr_history != 0b1)) {
  768|   112k|                float unmatched_bet = bets.top();
  769|   112k|                bets.pop();
  770|   112k|                pot_size += 2.0f * bets.top();
  771|   112k|                bets.push(unmatched_bet);
  772|   112k|                player = !player;
  773|   112k|                is_terminal = true;
  774|   112k|                bets.push(0.0f);
  775|   112k|            } else if (rvr_history == 0b1) { 
  776|  29.6k|                bets.push(0.0f);
  777|  29.6k|                is_terminal = true; // check check is terminal on river
  778|  29.6k|            } else {
  779|  29.6k|                bets.push(0.0f);
  780|  29.6k|            }
  781|   171k|        }
  782|   173k|    }
  783|       |    
  784|       |    /************************* Preflop *************************/
  785|       |
  786|   401k|    if (!flp_seen) {
  787|      0|        pfp_history = (pfp_history << 3) | a;
  788|      0|        return;
  789|      0|    }
  790|       |
  791|       |    /************************* Flop *************************/
  792|       |
  793|   401k|    if (!trn_seen) {
  794|      0|        flp_history = (flp_history << 3) | a;
  795|      0|        return;
  796|      0|    }
  797|       |
  798|       |    /************************* Turn *************************/
  799|       |
  800|   401k|    if (!rvr_seen) {
  801|  5.77k|        trn_history = (trn_history << 3) | a;
  802|  5.77k|        return;
  803|  5.77k|    }
  804|       |
  805|       |    /************************* River *************************/
  806|       |
  807|   395k|    rvr_history = (rvr_history << 3) | a;
  808|   395k|}
  809|       |
  810|   398k|void GameState::undo(bool prev_player, float prev_pot) {
  811|   398k|    is_terminal = false;
  812|   398k|    player = prev_player;
  813|   398k|    pot_size = prev_pot;
  814|   398k|    bets.pop();
  815|       |
  816|       |    // Chance actions
  817|   398k|    if (flp_seen && (flp_history==0)) {
  818|      0|        fp3=0; 
  819|      0|        flp_seen=false;
  820|      0|        return;
  821|      0|    }
  822|       |
  823|   398k|    if ((fp2!=0) && (flp_history==0)) {
  824|      0|        fp2=0; 
  825|      0|        return;
  826|      0|    }
  827|       |
  828|   398k|    if ((fp1!=0) && (flp_history==0)) {
  829|      0|        fp1=0;
  830|      0|        return;
  831|      0|    }
  832|       |
  833|   398k|    if (trn_seen && (trn_history==0)) {
  834|      0|        trn=0;
  835|      0|        trn_seen=false;
  836|      0|        return;
  837|      0|    }
  838|       |
  839|   398k|    if (rvr_seen && (rvr_history==0)) {
  840|  1.21k|        rvr=0;
  841|  1.21k|        rvr_seen=false;
  842|  1.21k|        return;
  843|  1.21k|    }
  844|       |
  845|       |    // Actual actions
  846|   397k|    if (rvr_history != 0) {
  847|   391k|        rvr_history >>= 3;
  848|   391k|        return;
  849|   391k|    } 
  850|       |
  851|  5.78k|    if (trn_history != 0) {
  852|  5.71k|        trn_history >>= 3;
  853|  5.71k|        return;
  854|  5.71k|    }
  855|       |
  856|     69|    if (flp_history != 0) {
  857|      0|        flp_history >>= 3;
  858|      0|        return;
  859|      0|    }
  860|       |
  861|     69|    if (pfp_history != 0) {
  862|      0|        pfp_history >>= 3;
  863|      0|        return;
  864|      0|    }
  865|     69|}
  866|       |
  867|  62.2k|void GameState::deal_card(uint8_t card) {
  868|  62.2k|    if (has_card(card)) throw std::runtime_error("Card already dealt");
  869|       |
  870|       |    // if (op1 == 0) op1 = card;
  871|       |    // else if (op2 == 0) op2 = card;
  872|       |    // else if (ip1 == 0) ip1 = card;
  873|       |    // else if (ip2 == 0) ip2 = card;
  874|       |
  875|  62.2k|    if (fp1 == 0) fp1 = card;
  876|  62.2k|    else if (fp2 == 0) fp2 = card;
  877|  62.2k|    else if (fp3 == 0) fp3 = card, flp_seen = true;
  878|  62.2k|    else if (trn == 0) trn = card, trn_seen = true;
  879|  62.3k|    else if (rvr == 0) {
  880|  62.3k|        rvr = card;
  881|  62.3k|        rvr_seen = true;
  882|  62.3k|        if (((pfp_history & 0b111111) == 0b110111) || 
  883|  62.3k|            ((flp_history & 0b111111) == 0b110111) ||
  884|  62.3k|            ((trn_history & 0b111111) == 0b110111) ||
  885|  62.3k|            ((rvr_history & 0b111111) == 0b110111))
  886|  32.8k|            is_terminal = true; // all-ins that have run out
  887|  62.3k|    }
  888|       |
  889|  62.2k|    player = 0;
  890|  62.2k|    bets.push(0.0f);
  891|  62.2k|}
  892|       |
  893|   370k|InfoSet GameState::to_information_set() const {
  894|   370k|    InfoSet is;
  895|       |
  896|   370k|    is.player = player;
  897|       |
  898|   370k|    is.cr1 = (player == 0) ? op1 : ip1;
  899|   370k|    is.cr2 = (player == 0) ? op2 : ip2;
  900|       |    
  901|   370k|    is.fp1 = fp1;
  902|   370k|    is.fp2 = fp2;
  903|   370k|    is.fp3 = fp3;
  904|   370k|    is.trn = trn;
  905|   370k|    is.rvr = rvr;
  906|       |
  907|   370k|    is.pfp_history = pfp_history;
  908|   370k|    is.flp_history = flp_history; 
  909|   370k|    is.trn_history = trn_history; 
  910|   370k|    is.rvr_history = rvr_history;
  911|       |
  912|   370k|    is.num_actions = num_actions();
  913|       |
  914|   370k|    return is;
  915|   370k|}
  916|       |
  917|      0|float GameState::rivr_hand_strength() {
  918|       |
  919|      0|    float wins = 0.0f;
  920|      0|    float total = 0.0f;
  921|       |
  922|      0|    ip1 = 0;
  923|      0|    ip2 = 0;
  924|       |
  925|      0|    for (int c1=1; c1<=NUM_CARDS; c1++) {
  926|      0|        for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  927|      0|            if (has_card(c1) || has_card(c2)) continue;
  928|      0|            if (c1==c2) continue;
  929|       |
  930|      0|            ip1 = c1;
  931|      0|            ip2 = c2;
  932|       |
  933|      0|            trn_seen = true;
  934|      0|            rvr_seen = true;
  935|       |
  936|      0|            int op_best = best_hand(0);
  937|      0|            int ip_best = best_hand(1);
  938|       |
  939|      0|            if (op_best > ip_best) {
  940|      0|                wins += 1.0f;   
  941|      0|            } else if (op_best == ip_best) {
  942|      0|                wins += 0.5f;
  943|      0|            }
  944|       |
  945|      0|            total += 1.0f;
  946|      0|        }
  947|      0|    }
  948|       |
  949|      0|    return wins/total;
  950|      0|}
  951|       |
  952|  3.47k|int GameState::p_id(bool p) const {
  953|  3.47k|    return (p==0) ? pocket_id(op1, op2) : pocket_id(ip1, ip2);
  954|  3.47k|}
  955|       |
  956|      7|std::string GameState::action_to_string(int action) const {
  957|       |
  958|      7|    std::stringstream ss;
  959|       |
  960|      7|    if (pot_size / 2.0f + bets.top() == STACK_SIZE) return (action == 1) ? "Fold" : "Call";
  961|       |    
  962|       |    /************************* Preflop *************************/
  963|       |    
  964|      7|    if (pfp_history == 0) {
  965|      0|        ss << RAISE_ACTION_NAMES[action-1];
  966|      0|        if ((action >= 2) && (action<=5)) ss << " to " << bets.top() * RAISE_SIZES[action-2];
  967|      0|        return ss.str();
  968|      0|    }
  969|       |    
  970|      7|    if (pfp_history == 0b111) {
  971|      0|        if (action == 1) return "Check";
  972|      0|        ss << RAISE_ACTION_NAMES[action-1];
  973|      0|        if ((action >= 2) && (action<=5)) ss << " to " << bets.top() * RAISE_SIZES[action-2];
  974|      0|        return ss.str();
  975|      0|    }
  976|       |    
  977|      7|    if (((pfp_history & 0b111) == 0b110) && // all-in; must fold or call
  978|      7|         (!flp_seen)) 
  979|      0|        return (action == 1) ? "Fold" : "Call";
  980|       |    
  981|      7|    if ((pfp_history < 0b1000000000) && // bet/raise; respond 1-7
  982|      7|        (!flp_seen)) {
  983|      0|        ss << RAISE_ACTION_NAMES[action-1];
  984|      0|        if ((action >= 2) && (action<=5)) ss << " to " << bets.top() * RAISE_SIZES[action-2];
  985|      0|        return ss.str();
  986|      0|    }
  987|       |    
  988|      7|    if ((pfp_history > 0b1000000000) && // bet/raise but at limit; 1 or 7
  989|      7|        (pfp_history < 0b1111111111111) &&
  990|      7|        (!flp_seen))
  991|      0|        return (action == 1) ? "Fold" : "Call";
  992|       |
  993|       |    /************************* Flop *************************/
  994|       |    
  995|      7|    if ((flp_history == 0) || (flp_history == 1)) {
  996|      0|        ss << BET_ACTION_NAMES[action-1];
  997|      0|        if ((action >= 2) && (action<=5)) ss << " " << pot_size * BET_SIZES[action-2];
  998|      0|        return ss.str();
  999|      0|    } 
 1000|       |    
 1001|      7|    if (((flp_history & 0b111) == 0b110) && // all-in; must fold or call
 1002|      7|         (!trn_seen)) 
 1003|      0|        return (action == 1) ? "Fold" : "Call";
 1004|       |    
 1005|      7|    if ((flp_history < 0b1000000000) && // bet/raise; respond 1-7
 1006|      7|        (!trn_seen)) {
 1007|      0|        ss << RAISE_ACTION_NAMES[action-1];
 1008|      0|        if ((action >= 2) && (action<=5)) ss << " to " << bets.top() * RAISE_SIZES[action-2];
 1009|      0|        return ss.str();
 1010|      0|    } 
 1011|       |    
 1012|      7|    if ((flp_history > 0b1000000000) && // bet/raise but at limit; call or fold
 1013|      7|        (flp_history < 0b1111111111111) &&
 1014|      7|        (!trn_seen))
 1015|      0|        return (action == 1) ? "Fold" : "Call";
 1016|       |
 1017|       |    /************************* Turn *************************/
 1018|       |    
 1019|      7|    if ((trn_history == 0) || (trn_history == 1)) {
 1020|      0|        ss << BET_ACTION_NAMES[action-1];
 1021|      0|        if ((action >= 2) && (action<=5)) ss << " " << pot_size * BET_SIZES[action-2];
 1022|      0|        return ss.str();
 1023|      0|    }
 1024|       |    
 1025|      7|    if (((trn_history & 0b111) == 0b110) && // all-in; must fold or call
 1026|      7|         (!rvr_seen)) 
 1027|      0|        return (action == 1) ? "Fold" : "Call";
 1028|       |    
 1029|      7|    if ((trn_history < 0b1000000000) && // bet/raise; respond 1-7
 1030|      7|        (!rvr_seen)) {
 1031|      7|        ss << RAISE_ACTION_NAMES[action-1];
 1032|      7|        if ((action >= 2) && (action<=5)) ss << " to " << bets.top() * RAISE_SIZES[action-2];
 1033|      7|        return ss.str();
 1034|      7|    }
 1035|       |    
 1036|      0|    if ((trn_history > 0b1000000000) && // bet/raise but at limit; call or fold
 1037|      0|        (trn_history < 0b1111111111111) &&
 1038|      0|        (!rvr_seen))
 1039|      0|        return (action == 1) ? "Fold" : "Call";
 1040|       |
 1041|       |    /************************* River *************************/
 1042|       |
 1043|      0|    if ((rvr_history == 0) || (rvr_history == 1)) {
 1044|      0|        ss << BET_ACTION_NAMES[action-1];
 1045|      0|        if ((action >= 2) && (action<=5)) ss << " " << pot_size * BET_SIZES[action-2];
 1046|      0|        return ss.str();
 1047|      0|    }  
 1048|       |    
 1049|      0|    if ((rvr_history & 0b111) == 0b110) // all-in; must fold or call 
 1050|      0|        return (action == 1) ? "Fold" : "Call";
 1051|       |    
 1052|      0|    if (rvr_history < 0b1000000000) {
 1053|      0|        ss << RAISE_ACTION_NAMES[action-1];
 1054|      0|        if ((action >= 2) && (action<=5)) ss << " to " << bets.top() * RAISE_SIZES[action-2];
 1055|      0|        return ss.str();
 1056|      0|    }
 1057|       |    
 1058|      0|    if ((rvr_history > 0b1000000000) && // bet/raise but at limit; call or fold
 1059|      0|        (rvr_history < 0b1111111111111))
 1060|      0|        return (action == 1) ? "Fold" : "Call";
 1061|       |
 1062|      0|    return "";
 1063|      0|}
 1064|       |
 1065|      0|std::string GameState::histories_to_string() const {
 1066|      0|    std::stringstream ss;
 1067|       |
 1068|       |    // int i=0;
 1069|       |
 1070|       |    // while (ith_action(history, i) != 0) i++;
 1071|       |
 1072|       |    // for (int k=i-1; k>=0; k--) {
 1073|       |    //     ss << action_to_string(ith_action(history, i)) << " ";
 1074|       |    // }
 1075|       |
 1076|      0|    return ss.str();
 1077|      0|}
 1078|       |
 1079|  3.47k|std::array<int, 2> pocket_id_to_row_col(int id) {
 1080|  3.47k|    return {8-(id/9), 8-(id%9)};
 1081|  3.47k|}
 1082|       |
 1083|      0|void GameState::print_range(int index) const {
 1084|       |
 1085|      0|    try {
 1086|      0|        load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
 1087|      0|    } catch (const std::runtime_error& e) {
 1088|      0|        std::cerr << "Error: " << e.what() << std::endl;
 1089|      0|        return;
 1090|      0|    }
 1091|       |
 1092|      0|    int action = index_to_action(index);
 1093|       |
 1094|      0|    std::string player_name = (player==0) ? "OOP" : "IP"; 
 1095|       |
 1096|      0|    std::cout << "\n******************* Board ********************\n" << to_string();
 1097|      0|    std::cout << "\n************** " << player_name << " Range: " << action_to_string(action) << " ***************\n";
 1098|       |
 1099|      0|    std::array<std::array<float, 9>, 9> range;
 1100|       |
 1101|      0|    for (int p1=1; p1<=NUM_CARDS; p1++) {
 1102|      0|        for (int p2=p1+1; p2<=NUM_CARDS; p2++) {
 1103|      0|            GameState temp = *this;
 1104|       |
 1105|      0|            if ((temp.has_card(p1)) ||
 1106|      0|                (temp.has_card(p2))) continue;
 1107|       |
 1108|      0|            if (temp.player==0) {
 1109|      0|                temp.op1 = p1;
 1110|      0|                temp.op2 = p2;
 1111|      0|            } else {
 1112|      0|                temp.ip1 = p1;
 1113|      0|                temp.ip2 = p2;
 1114|      0|            }
 1115|       |
 1116|      0|            InfoSet is = temp.to_information_set();
 1117|       |
 1118|       |            // std::cout << strategy_sum[is.hash()] << "\n";
 1119|       |
 1120|      0|            std::array<int, 2> row_col = pocket_id_to_row_col(temp.p_id(player));
 1121|       |            
 1122|      0|            range[row_col[0]][row_col[1]] = get_average_strategy(is)[action_to_index(action)];
 1123|      0|        }
 1124|      0|    }
 1125|       |
 1126|      0|    for (int r=0; r<10; r++) {
 1127|      0|        for (int c=0; c<10; c++) {
 1128|      0|            if (c==0 && r==0) {
 1129|      0|                std::cout << "    ";
 1130|      0|            } else if (r==0 && c>0) {
 1131|      0|                std::cout << CARD_NAMES[9-c] << "s   ";
 1132|      0|            } else if (c==0 && r>0) {
 1133|      0|                std::cout << CARD_NAMES[9-r] << " ";
 1134|      0|            } else {
 1135|      0|                std::cout << FIXED_FLOAT(range[r-1][c-1]) << " ";
 1136|      0|            }
 1137|      0|        }
 1138|      0|        std::cout << "\n";
 1139|      0|    }
 1140|      0|    std::cout << "\n";
 1141|      0|}
 1142|       |
 1143|      7|void GameState::print_range_turn(int index) const {
 1144|       |
 1145|      7|    try {
 1146|      7|        load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
 1147|      7|    } catch (const std::runtime_error& e) {
 1148|      0|        std::cerr << "Error: " << e.what() << std::endl;
 1149|      0|        return;
 1150|      0|    }
 1151|       |
 1152|      7|    int action = index_to_action(index);
 1153|       |
 1154|      7|    std::string player_name = (player==0) ? "OOP" : "IP"; 
 1155|       |
 1156|      7|    std::cout << "\n******************* Board ********************\n" << to_string();
 1157|      7|    std::cout << "\n************** " << player_name << " Range: " << action_to_string(action) << " ***************\n";
 1158|       |
 1159|      7|    std::array<std::array<float, 9>, 9> range;
 1160|      7|    std::array<std::array<float, 9>, 9> count;
 1161|       |
 1162|     70|    for (int r=0; r<9; r++) {
 1163|    630|        for (int c=0; c<9; c++) {
 1164|    567|            range[r][c] = count[r][c] = 0.0f;
 1165|    567|        }
 1166|     63|    }
 1167|       |
 1168|    259|    for (int p1=1; p1<=NUM_CARDS; p1++) {
 1169|  4.66k|        for (int p2=p1+1; p2<=NUM_CARDS; p2++) {
 1170|  4.41k|            GameState temp = *this;
 1171|       |            // std::cout << temp.to_string() << "\n";
 1172|       |            
 1173|  4.41k|            if ((temp.has_card(p1)) ||
 1174|  4.41k|                (temp.has_card(p2))) continue;
 1175|       |
 1176|  3.47k|            if (temp.player==0) {
 1177|      0|                temp.op1 = p1;
 1178|      0|                temp.op2 = p2;
 1179|  3.47k|            } else {
 1180|  3.47k|                temp.ip1 = p1;
 1181|  3.47k|                temp.ip2 = p2;
 1182|  3.47k|            }
 1183|       |
 1184|  3.47k|            InfoSet is = temp.to_information_set();
 1185|       |
 1186|       |            // std::cout << strategy_sum[is.hash()] << "\n";
 1187|       |
 1188|  3.47k|            std::array<int, 2> row_col = pocket_id_to_row_col(temp.p_id(player));
 1189|       |            
 1190|  3.47k|            range[row_col[0]][row_col[1]] += get_average_strategy(is)[action_to_index(action)];
 1191|  3.47k|            count[row_col[0]][row_col[1]] += 1.0f;
 1192|  3.47k|        }
 1193|    252|    }
 1194|       |
 1195|     77|    for (int r=0; r<10; r++) {
 1196|    770|        for (int c=0; c<10; c++) {
 1197|    700|            if (c==0 && r==0) {
 1198|      7|                std::cout << "    ";
 1199|    693|            } else if (r==0 && c>0) {
 1200|     63|                std::cout << CARD_NAMES[9-c] << "s   ";
 1201|    630|            } else if (c==0 && r>0) {
 1202|     63|                std::cout << CARD_NAMES[9-r] << " ";
 1203|    567|            } else {
 1204|    567|                std::cout << FIXED_FLOAT(range[r-1][c-1]/count[r-1][c-1]) << " ";
 1205|    567|            }
 1206|    700|        }
 1207|     70|        std::cout << "\n";
 1208|     70|    }
 1209|      7|    std::cout << "\n";
 1210|      7|}
 1211|       |
 1212|      0|int ith_action(uint32_t history, int i) {
 1213|      0|    return ((history & OCTAL_MASKS[i]) >> (3*i));
 1214|      0|}
 1215|       |
 1216|      0|GameState generate_random_initial_state() {
 1217|       |
 1218|       |    // Generate unique card indices
 1219|      0|    std::array<int, 4> card_indices;
 1220|      0|    for (int i=0; i<4; ++i) {
 1221|      0|        do {
 1222|      0|            card_indices[i] = get_card_distribution()(get_random_generator());
 1223|      0|        } while (std::find(card_indices.begin(), card_indices.begin() + i, card_indices[i]) != card_indices.begin() + i);
 1224|      0|    }
 1225|       |
 1226|      0|    GameState gs;
 1227|       |
 1228|      0|    gs.op1 = card_indices[0];
 1229|      0|    gs.op2 = card_indices[1];
 1230|      0|    gs.ip1 = card_indices[2];
 1231|      0|    gs.ip2 = card_indices[3];
 1232|      0|    gs.bets.push(1.0f);
 1233|      0|    gs.bets.push(2.0f);
 1234|       |
 1235|      0|    return gs;
 1236|      0|}
 1237|       |
 1238|      0|void play_computer() {
 1239|      0|    bool p = 0; // start as oop
 1240|      0|    float cumulative_winnings = 0.0f;
 1241|      0|    bool keep_playing = true;
 1242|       |
 1243|      0|    load_cfr_data("latest_checkpoint.dat", regret_sum, strategy_sum);
 1244|       |
 1245|      0|    while (keep_playing == true) {
 1246|      0|        GameState gs = generate_random_initial_state();
 1247|       |
 1248|      0|        while (!gs.is_terminal) {
 1249|      0|            while (gs.is_chance()){
 1250|       |                // get random card out of cards remaining
 1251|      0|                uint8_t c = get_card_distribution()(get_random_generator());
 1252|      0|                while (gs.has_card(c)) 
 1253|      0|                    c = get_card_distribution()(get_random_generator());
 1254|      0|                gs.deal_card(c);
 1255|      0|            }
 1256|       |
 1257|      0|            if (gs.is_terminal) {
 1258|      0|                break;
 1259|      0|            }
 1260|       |
 1261|      0|            InfoSet is = gs.to_information_set();
 1262|      0|            std::array<float, 7> average_strategy = get_average_strategy(is);
 1263|       |
 1264|       |            // Mask out opponent's cards when displaying to user
 1265|      0|            GameState temp = gs;
 1266|       |
 1267|      0|            if (p==0) temp.ip1 = 0, temp.ip2 = 0;
 1268|      0|            if (p==1) temp.op1 = 0, temp.op2 = 0;
 1269|       |
 1270|      0|            std::cout << "**********************************************\n";
 1271|      0|            std::cout << temp.to_string() << "\n";
 1272|       |
 1273|      0|            if (gs.player==p) {
 1274|       |                // Player's turn
 1275|      0|                std::cout << "Player turn. Input action: ";
 1276|       |
 1277|      0|                int action;
 1278|      0|                std::cin >> action;
 1279|       |
 1280|      0|                std::cout << "GTO strategy:\n";
 1281|       |
 1282|      0|                for (int i=0; i<gs.num_actions(); i++) {
 1283|      0|                    std::cout << gs.action_to_string(gs.index_to_action(i)) << ": " << FIXED_FLOAT(average_strategy[i])*100 << "%";
 1284|      0|                    if (i!=gs.num_actions()-1) std::cout << ", ";
 1285|      0|                }
 1286|       |
 1287|      0|                std::cout << "\n**********************************************\n\n";
 1288|       |
 1289|       |                // std::cout << "GTO strategy: " << average_strategy << "\n**********************************************\n\n";
 1290|       |
 1291|      0|                gs.apply_index(gs.action_to_index(action));
 1292|      0|            } else {
 1293|       |                // Computer's turn
 1294|      0|                int sampled_index = sample_action(average_strategy);
 1295|       |
 1296|      0|                std::cout << "Computer turn. " << gs.action_to_string(gs.index_to_action(sampled_index)) << "\n**********************************************\n\n";
 1297|       |                // std::cout << "GTO strategy: " << average_strategy << "\n**********************************************\n\n";
 1298|       |                
 1299|      0|                gs.apply_index(sampled_index);
 1300|      0|            }
 1301|      0|        }
 1302|      0|        std::cout << "Terminal game state:\n" << gs.to_string() << "\n";
 1303|      0|        cumulative_winnings += gs.utility(p);
 1304|      0|        std::cout << "HAND WINNINGS: " << gs.utility(p) << "\n";
 1305|      0|        std::cout << "CUMULATIVE WINNINGS: " << cumulative_winnings << "\n**********************************************\n";
 1306|      0|        std::cout << "Continue playing? (Y/n): "; 
 1307|       |
 1308|      0|        char in;
 1309|      0|        std::cin >> in;
 1310|      0|        if (in=='n') keep_playing = false;
 1311|      0|        p = !p; // alternate player
 1312|      0|    }
 1313|      0|}
 1314|       |
 1315|       |// int GameState::best_hand_fast(bool p) const {
 1316|       |//     std::array<uint16_t, 4> suits = {0, 0, 0, 0};
 1317|       |    
 1318|       |//     uint8_t c1 = (p==0) ? op1 : ip1;
 1319|       |//     uint8_t c2 = (p==0) ? op2 : ip2;
 1320|       |
 1321|       |//     suits[suit(c1)] |= (1U << rank(c1));
 1322|       |//     suits[suit(c2)] |= (1U << rank(c2));
 1323|       |
 1324|       |//     if (fp1 > 0) suits[suit(fp1)] |= (1U << rank(fp1));
 1325|       |//     if (fp2 > 0) suits[suit(fp2)] |= (1U << rank(fp2));
 1326|       |//     if (fp3 > 0) suits[suit(fp3)] |= (1U << rank(fp3));
 1327|       |
 1328|       |//     if (trn > 0) suits[suit(trn)] |= (1U << rank(trn));
 1329|       |//     if (rvr > 0) suits[suit(rvr)] |= (1U << rank(rvr));
 1330|       |
 1331|       |//     /************************* Straight flush *************************/
 1332|       |
 1333|       |//     for (int i=0; i<6; i++) {
 1334|       |//         if (((suits[0] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i]) ||
 1335|       |//             ((suits[1] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i]) ||
 1336|       |//             ((suits[2] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i]) || 
 1337|       |//             ((suits[3] & STRAIGHT_MASKS[i]) == STRAIGHT_MASKS[i])) {
 1338|       |//             return 900000 + (6-i)*10000;
 1339|       |//         }
 1340|       |//     }
 1341|       |
 1342|       |//     /************************* Flush *************************/
 1343|       |    
 1344|       |//     int best = -1;
 1345|       |
 1346|       |//     for (int i=0; i<4; i++) {
 1347|       |//         if (__builtin_popcount(suits[i]) >= 5) {
 1348|       |//             // find highest card in the flush
 1349|       |//             for (int k=0; k<9; k++) {
 1350|       |//                 if (suits[i] & SINGLE_MASKS[k]) {
 1351|       |//                     best = 9-k;
 1352|       |//                     break;
 1353|       |//                 }
 1354|       |//             }
 1355|       |//         }
 1356|       |//     }
 1357|       |
 1358|       |//     if (best != -1) return 700000 + best*10000;
 1359|       |
 1360|       |//     /************************* Other *************************/
 1361|       |
 1362|       |//     uint64_t hand_id = 0;
 1363|       |//     hand_id |= (1U<<(rank(c1) + suit(c1)*16));
 1364|       |//     hand_id |= (1U<<(rank(c2) + suit(c2)*16));
 1365|       |//     hand_id |= (1U<<(rank(fp1) + suit(fp1)*16));
 1366|       |//     hand_id |= (1U<<(rank(fp2) + suit(fp2)*16));
 1367|       |//     hand_id |= (1U<<(rank(fp3) + suit(fp3)*16));
 1368|       |//     hand_id |= (1U<<(rank(trn) + suit(trn)*16));
 1369|       |//     hand_id |= (1U<<(rank(rvr) + suit(rvr)*16));
 1370|       |
 1371|       |//     int hash = fast_hash(hand_id, 7);
 1372|       |//     return rank_table[hash];
 1373|       |// }
 1374|       |
 1375|       |// int n_choose_k(int n, int k) {
 1376|       |//     if (k > n) return 0;
 1377|       |//     if (k * 2 > n) k = n-k;
 1378|       |//     if (k == 0) return 1;
 1379|       |
 1380|       |//     int result = n;
 1381|       |//     for (int i=2; i<=k; ++i) {
 1382|       |//         result *= (n-i+1);
 1383|       |//         result /= i;
 1384|       |//     }
 1385|       |
 1386|       |//     return result;
 1387|       |// }
 1388|       |
 1389|       |// int fast_hash(uint64_t hand_id, int k) {
 1390|       |//   int hash = 0;
 1391|       |
 1392|       |//   unsigned short * a = (unsigned short *)&hand_id;
 1393|       |
 1394|       |//   hash += dp[a[3]][3][k];
 1395|       |//   k -= __builtin_popcount(a[3]);
 1396|       |
 1397|       |//   hash += dp[a[2]][2][k];
 1398|       |//   k -= __builtin_popcount(a[2]);
 1399|       |
 1400|       |//   hash += dp[a[1]][1][k];
 1401|       |//   k -= __builtin_popcount(a[1]);
 1402|       |
 1403|       |//   hash += dp[a[0]][0][k];
 1404|       |
 1405|       |//   return hash;
 1406|       |// }
 1407|       |
 1408|       |// void generate_dp_table() {
 1409|       |//     for (int i = 0; i < 65536; i++) {
 1410|       |//         for (int j = 0; j < 4; j++) {
 1411|       |//             for (int k = 0; k < 8; k++) {
 1412|       |//                 int ck = k;
 1413|       |//                 int sum = 0;
 1414|       |
 1415|       |//                 for (int s = 15; s >= 0; s--) {
 1416|       |//                     if (i & (1 << s)) {
 1417|       |//                         int n = j * 16 + s;
 1418|       |
 1419|       |//                         sum += n_choose_k(n, ck);
 1420|       |
 1421|       |//                         ck--;
 1422|       |//                     }
 1423|       |//                 }
 1424|       |
 1425|       |//                 dp[i][j][k] = sum;
 1426|       |//             }
 1427|       |//         }
 1428|       |//     }
 1429|       |// }
 1430|       |
 1431|       |// void generate_rank_table() {
 1432|       |//     generate_dp_table();
 1433|       |//     for (int c1=1; c1<=NUM_CARDS; c1++) {
 1434|       |//         for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
 1435|       |//             for (int c3=c2+1; c3<=NUM_CARDS; c3++) {
 1436|       |//                 for (int c4=c3+1; c4<=NUM_CARDS; c4++) {
 1437|       |//                     for (int c5=c4+1; c5<=NUM_CARDS; c5++) {
 1438|       |//                         for (int c6=c5+1; c6<=NUM_CARDS; c6++) {
 1439|       |//                             for (int c7=c6+1; c7<=NUM_CARDS; c7++) {
 1440|       |//                                 uint64_t hand_id = 0;
 1441|       |
 1442|       |//                                 hand_id |= (1U<<(rank(c1) + suit(c1)*16));
 1443|       |//                                 hand_id |= (1U<<(rank(c2) + suit(c2)*16));
 1444|       |//                                 hand_id |= (1U<<(rank(c3) + suit(c3)*16));
 1445|       |//                                 hand_id |= (1U<<(rank(c4) + suit(c4)*16));
 1446|       |//                                 hand_id |= (1U<<(rank(c5) + suit(c5)*16));
 1447|       |//                                 hand_id |= (1U<<(rank(c6) + suit(c6)*16));
 1448|       |//                                 hand_id |= (1U<<(rank(c7) + suit(c7)*16));
 1449|       |//                                 int hash = fast_hash(hand_id, 7);
 1450|       |
 1451|       |//                                 GameState state;
 1452|       |//                                 state.op1 = c1;
 1453|       |//                                 state.op2 = c2;
 1454|       |//                                 state.fp1 = c3;
 1455|       |//                                 state.fp2 = c4;
 1456|       |//                                 state.fp3 = c5;
 1457|       |//                                 state.trn = c6;
 1458|       |//                                 state.rvr = c7;
 1459|       |//                                 int hand_rank = state.best_hand(0);
 1460|       |
 1461|       |//                                 rank_table[hash] = hand_rank;
 1462|       |//                             }
 1463|       |//                         }
 1464|       |//                     }
 1465|       |//                 }
 1466|       |//             }
 1467|       |//         }
 1468|       |//     }
 1469|       |// }
 1470|       |
 1471|       |// void test_rank_table() {
 1472|       |//     generate_rank_table();
 1473|       |//     for (int c1=1; c1<=NUM_CARDS; c1++) {
 1474|       |//         for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
 1475|       |//             for (int c3=c2+1; c3<=NUM_CARDS; c3++) {
 1476|       |//                 for (int c4=c3+1; c4<=NUM_CARDS; c4++) {
 1477|       |//                     for (int c5=c4+1; c5<=NUM_CARDS; c5++) {
 1478|       |//                         for (int c6=c5+1; c6<=NUM_CARDS; c6++) {
 1479|       |//                             for (int c7=c6+1; c7<=NUM_CARDS; c7++) {                                
 1480|       |//                                 GameState state;
 1481|       |//                                 state.op1 = c1;
 1482|       |//                                 state.op2 = c2;
 1483|       |//                                 state.fp1 = c3;
 1484|       |//                                 state.fp2 = c4;
 1485|       |//                                 state.fp3 = c5;
 1486|       |//                                 state.trn = c6;
 1487|       |//                                 state.rvr = c7;
 1488|       |//                                 state.flp_seen = true;
 1489|       |//                                 state.trn_seen = true;
 1490|       |//                                 state.rvr_seen = true;
 1491|       |//                                 state.pfp_history = 0b111001;
 1492|       |//                                 state.flp_history = 0b1001;
 1493|       |
 1494|       |//                                 if (state.best_hand_fast(0) != state.best_hand(0)) {
 1495|       |//                                     std::cout << "ERROR\n";
 1496|       |//                                     std::cout << "fast: " << state.best_hand_fast(0) << "\n";
 1497|       |//                                     std::cout << "slow: " << state.best_hand(0) << "\n";
 1498|       |//                                     std::cout << state.to_string() << "\n";
 1499|       |//                                 }
 1500|       |//                             }
 1501|       |//                         }
 1502|       |//                     }
 1503|       |//                 }
 1504|       |//             }
 1505|       |//         }
 1506|       |//     }
 1507|       |// }

/Users/glen/cfr/shortdecknoluckupdate/src/info_set.cpp:
    1|       |#include "info_set.h"
    2|       |
    3|       |InfoSet::InfoSet(): player(false),
    4|       |                    cr1(0),
    5|       |                    cr2(0),
    6|       |                    fp1(0),
    7|       |                    fp2(0),
    8|       |                    fp3(0),
    9|       |                    trn(0),
   10|       |                    rvr(0),
   11|       |                    pfp_history(0),
   12|       |                    flp_history(0),
   13|       |                    trn_history(0),
   14|       |                    rvr_history(0),
   15|   370k|                    num_actions(0) {}
   16|       |
   17|      0|std::string InfoSet::to_string() const {
   18|      0|    std::stringstream ss;
   19|      0|    return ss.str();
   20|      0|}
   21|       |
   22|       |template <typename T>
   23|  1.93G|inline void hash_combine(std::size_t& seed, const T& value) {
   24|  1.93G|    std::hash<T> hasher;
   25|  1.93G|    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
   26|  1.93G|}
  ------------------
  | Unexecuted instantiation: _Z12hash_combineIiEvRmRKT_
  ------------------
  | _Z12hash_combineIhEvRmRKT_:
  |   23|  1.19G|inline void hash_combine(std::size_t& seed, const T& value) {
  |   24|  1.19G|    std::hash<T> hasher;
  |   25|  1.19G|    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
  |   26|  1.19G|}
  ------------------
  | _Z12hash_combineIjEvRmRKT_:
  |   23|   740M|inline void hash_combine(std::size_t& seed, const T& value) {
  |   24|   740M|    std::hash<T> hasher;
  |   25|   740M|    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
  |   26|   740M|}
  ------------------
   27|       |
   28|   196M|size_t InfoSet::hash() const {
   29|   196M|    size_t seed = 1234;
   30|       |    
   31|   196M|    if (fp3 == 0) hash_combine(seed, pocket_id(cr1, cr2));
   32|   196M|    else { hash_combine(seed, cr1); hash_combine(seed, cr2); }
   33|       |    
   34|   196M|    hash_combine(seed, fp1);
   35|   196M|    hash_combine(seed, fp2);
   36|   196M|    hash_combine(seed, fp3);
   37|   196M|    hash_combine(seed, trn);
   38|   196M|    hash_combine(seed, rvr);
   39|   196M|    hash_combine(seed, pfp_history);
   40|   196M|    hash_combine(seed, flp_history);
   41|   196M|    hash_combine(seed, trn_history);
   42|   196M|    hash_combine(seed, rvr_history);
   43|       |
   44|   196M|    return seed % STRATEGY_ARRAY_SIZE;
   45|   196M|}

/Users/glen/cfr/shortdecknoluckupdate/src/main.cpp:
    1|       |#include <iostream>
    2|       |
    3|       |#include "game_state.h"
    4|       |#include "constants.h"
    5|       |#include "info_set.h"
    6|       |#include "best_response.h"
    7|       |#include "cfr.h"
    8|       |#include "tree.h"
    9|       |
   10|      1|int main(int argc, char* argv[]) {
   11|       |    // if (argc > 1) {
   12|       |    //     std::string arg = argv[1];
   13|       |    //     if (arg == "train") {
   14|       |    //         int iterations = 1000000;  // Default value
   15|       |    //         if (argc > 2) {
   16|       |    //             iterations = std::stoi(argv[2]);
   17|       |    //         }
   18|       |    //         std::cout << "Training for " << iterations << " iterations..." << std::endl;
   19|       |    //         as_mccfr(iterations);
   20|       |    //         std::cout << "Training complete." << std::endl;
   21|       |    //     } else if (arg == "play") {
   22|       |    //         play_computer();
   23|       |    //     } else if (arg == "generate-ars") {
   24|       |    //         std::cout << "Generating ARS table. This may take a while..." << std::endl;
   25|       |    //         generate_ars_tables();
   26|       |    //         std::cout << "ARS table generation complete. File 'ars_table.dat' created." << std::endl;
   27|       |    //     } else if (arg == "exploit") {
   28|       |    //         int hands = 1000;  // Default value
   29|       |    //         if (argc > 2) {
   30|       |    //             hands = std::stoi(argv[2]);
   31|       |    //         }
   32|       |    //         std::cout << "Calculating approximate exploitability over " << hands << " hands..." << std::endl;
   33|       |    //         calculate_exploitability(hands);
   34|       |    //     } else {
   35|       |    //         std::cout << "Invalid argument. Use 'train', 'play', 'generate-ars', or 'exploit'." << std::endl;
   36|       |    //     }
   37|       |    // } else {
   38|       |    //     std::cout << "Usage: ./shortdeck [train <iterations>|play|generate-ars|exploit <hands>]" << std::endl;
   39|       |    // }
   40|       |    // return 0;
   41|       |
   42|       |    // GameState gs;
   43|       |
   44|       |    //SB cards:   7♠K♥
   45|       |	//BB cards:   7♥9♥
   46|       |	//Flop cards: T♥K♦7♣
   47|       |	//Turn card:  8♥
   48|       |	//River card: T♦
   49|       |
   50|       |	// gs.suita |= (0b1<<1); // sb7s
   51|       |	// gs.suitb |= (0b1<<7); // sbKh
   52|       |
   53|       |	// gs.suitb |= (0b1<<10); // bb7h
   54|       |	// gs.suitb |= (0b1<<12); // bb9h
   55|       |
   56|       |	// gs.suitb |= (0b1<<22); // Th
   57|       |	// gs.suitc |= (0b1<<25); // Kd
   58|       |	// gs.suitd |= (0b1<<19); // 7c
   59|       |	// gs.turn = 0b010010; // 8h
   60|       |	// gs.rivr = 0b100100; // Td
   61|       |
   62|       |	// gs.pflp_history = 0b111001;
   63|       |	// gs.flop_history = 0b1110111;
   64|       |	// gs.pot_size = 200;
   65|       |
   66|       |	// gs.turn_seen = true;
   67|       |	// gs.rivr_seen = true;
   68|       |	// gs.flop_seen = true;
   69|       |
   70|       |    // std::cout << gs.to_string() << "\n";
   71|       |
   72|       |    // std::cout << "sb best hand: " << gs.best_hand(0);
   73|       |    // std::cout << "\nbb best hand: " << gs.best_hand(1) << "\n";
   74|       |
   75|       |    // std::cout << "sb utility: " << gs.utility(0);
   76|       |    // std::cout << "\nbb utility: " << gs.utility(1) << "\n";
   77|       |
   78|       |    // const int NUM_SAMPLES = 5000;
   79|       |    // float total = 0.0f;
   80|       |    // for (int i=0; i<NUM_SAMPLES; i++) {
   81|       |    // 	GameState random = generate_random_initial_state();
   82|       |	//     random.apply_chance_action(32);
   83|       |	//     random.apply_chance_action(31);
   84|       |	//     random.apply_chance_action(30);
   85|       |	//     random.apply_action(0);
   86|       |	//     random.apply_action(0);
   87|       |	//     random.apply_chance_action(29);
   88|       |	//     random.apply_action(0);
   89|       |	//     random.apply_action(0);
   90|       |	//     random.apply_chance_action(28);
   91|       |	//     total += random.rivr_hand_strength();
   92|       |
   93|       |
   94|       |	//     //std::cout << random.to_string();
   95|       |	//     //std::cout << random.rivr_hand_strength() << "\n\n";
   96|       |    // }
   97|       |
   98|       |    // std::vector<float> flop = calculate_flop_bucket_boundaries();
   99|       |    // std::vector<float> turn = calculate_turn_bucket_boundaries();
  100|       |    // std::vector<float> rivr = calculate_rivr_bucket_boundaries();
  101|       |	
  102|       |	// std::cout << "Flop: {";
  103|       |    // for (int i=0; i<FLOP_BUCKETS; i++) std::cout << flop[i] << "f, ";
  104|       |    // std::cout << "}\nTurn: {";
  105|       |    // for (int i=0; i<TURN_BUCKETS; i++) std::cout << turn[i] << "f, ";
  106|       |    // std::cout << "}\nRivr: {";
  107|       |	// for (int i=0; i<RIVR_BUCKETS; i++) std::cout << rivr[i] << "f, ";
  108|       |	// std::cout << "}";
  109|       |
  110|       |
  111|       |
  112|       |    // for (int i=0; i<10; i++) {
  113|       |    // 	GameState random = generate_random_initial_state();
  114|       |    // 	// random.apply_action(1);
  115|       |    // 	// random.apply_chance_action(32);
  116|       |    // 	// random.apply_chance_action(31);
  117|       |    // 	// random.apply_chance_action(30);
  118|       |
  119|       |	//     std::cout << "Board:\n" << random.to_string() << "\nInformation set:\n";
  120|       |	    
  121|       |	//     InfoSet is = random.to_information_set();
  122|       |
  123|       |	//     std::cout << is.to_string() << "\n";
  124|       |    // }
  125|       |
  126|       |    // std::cout << "1\n";
  127|       |
  128|       |    // std::cout << ars_table(0, 3987, 71) << "\n";
  129|       |    // generate_ARS_tables();
  130|       |
  131|       |    // ars_table.load_from_file("ars_table.dat");
  132|       |
  133|       |    // std::array<int, TURN_BUCKETS> buckets;
  134|       |
  135|       |    // for (int i=0; i<TURN_BUCKETS; i++) buckets[i]=0;
  136|       |
  137|       |	// for (int r=0; r<20; r++) {
  138|       |	//     for (int p1=0; p1<36; p1++) {
  139|       |	//     	for (int p2=p1+1; p2<36; p2++) {
  140|       |	//     		std::array<uint16_t, 4> suits = {0, 0, 0, 0};
  141|       |
  142|       |	//     		suits[p1/9] |= ((0b1)<<(p1%9));
  143|       |	//     		suits[p2/9] |= ((0b1)<<(p2%9));
  144|       |
  145|       |	//     		GameState gs;
  146|       |
  147|       |	//     		gs.suita = suits[0];
  148|       |	// 			gs.suitb = suits[1];
  149|       |	// 			gs.suitc = suits[2];
  150|       |	// 			gs.suitd = suits[3];
  151|       |
  152|       |	// 		    gs.apply_chance_action(32);
  153|       |	// 		    gs.apply_chance_action(31);
  154|       |	// 		    gs.apply_chance_action(30);
  155|       |	// 		    gs.apply_index(gs.action_to_index(1)); // check
  156|       |	// 		    gs.apply_index(gs.action_to_index(1)); // check
  157|       |	// 		    gs.apply_chance_action(29);
  158|       |	// 		    gs.apply_index(gs.action_to_index(1)); // check
  159|       |	// 		    gs.apply_index(gs.action_to_index(1)); // check
  160|       |	// 		    gs.apply_chance_action(28);
  161|       |
  162|       |	// 		    int p_id = pocket_id(p1,p2);
  163|       |	// 		    int rank = gs.best_hand(0)/100;
  164|       |
  165|       |	// 		    // if (ars_table(2, rank, p_id)<=0.05) {
  166|       |	// 		    // 	std::cout << gs.to_string() << "\n\n";
  167|       |	// 		    // }
  168|       |
  169|       |	// 		    buckets[ars_to_bucket_rivr(ars_table(2, rank, p_id))]++;
  170|       |	// 		}
  171|       |	//     } 
  172|       |	// }
  173|       |
  174|       |	// generate_dp_table();
  175|       |	//generate_rank_table();
  176|       |	//test_rank_table();
  177|       |
  178|       |	// for (int i=0; i<5; i++) {
  179|       |	// 	std::array<std::array<float, 36>, 36> range;
  180|       |	//     for (int r=0; r<36; r++) {
  181|       |	//     	for (int c=0; c<36; c++) {
  182|       |	//     		range[r][c] = (r==c) ? 0.0f : 1.0f / (36.0f * 35.0f);
  183|       |	//     	}	
  184|       |	//     }
  185|       |
  186|       |	//     std::array<int, 4> turn_cards = {0, 17, 7, 24};
  187|       |	//     int pot_size = 0;
  188|       |
  189|       |	//     GameState gs = random_state_from_ranges(range, range, turn_cards, pot_size);
  190|       |	//     std::cout << gs.to_string() << "\n";
  191|       |	// }
  192|       |
  193|      1|	std::array<uint8_t, 5> board_cards = {1, 16, 21, 25, 0};	
  194|      1|	float pot_size = 60.0f;
  195|      1|    int iterations = 50;
  196|       |
  197|      1|	GameState gs;
  198|       |
  199|      1|	gs.fp1 = board_cards[0];
  200|      1|	gs.fp2 = board_cards[1];
  201|      1|	gs.fp3 = board_cards[2];
  202|      1|	gs.trn = board_cards[3];
  203|      1|	gs.pfp_history = 0b111001;
  204|      1|	gs.flp_history = 0b1001;
  205|      1|	gs.pot_size = pot_size;
  206|      1|	gs.flp_seen = true;
  207|      1|	gs.trn_seen = true;
  208|       |
  209|      1|	Tree t = Tree(gs);
  210|       |
  211|      1|	std::array<std::array<float, NUM_CARDS>, NUM_CARDS> range;
  212|     37|	for (int r=0; r<NUM_CARDS; r++) range[r].fill(0.0f);
  213|       |
  214|     37|	for (int c1=1; c1<=NUM_CARDS; c1++) {
  215|    666|    	for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
  216|    630|			if (gs.has_card(c1) || gs.has_card(c2)) continue; 
  217|    496|    		range[c1 - 1][c2 - 1] = 1.0f / (32.0f * 31.0f / 2.0f);
  218|    496|    	}	
  219|     36|    }
  220|       |
  221|       |    // std::cout << "Number of action nodes: " << count_nodes(gs) << "\n";
  222|       |
  223|       |    // print_opponent_reach_probabilities(range);
  224|       |
  225|       |	//as_mccfr(iterations, range, range, board_cards, pot_size);
  226|       |	// generate_rank_table();
  227|       |	//test_rank_table();
  228|      1|	cfr_plus_parallel(iterations, range, range, board_cards, pot_size);
  229|       |
  230|      1|    std::cout << "threads: " << std::thread::hardware_concurrency() << "\n";
  231|       |
  232|       |	// play_computer();
  233|       |
  234|       |	// as_mccfr(1000);
  235|       |
  236|      8|	for (int k=0; k<7; k++) {
  237|      7|		GameState gs;
  238|       |
  239|      7|		gs.fp1 = board_cards[0];
  240|      7|	    gs.fp2 = board_cards[1];
  241|      7|	    gs.fp3 = board_cards[2];
  242|      7|	    gs.trn = board_cards[3];
  243|      7|	   	gs.pfp_history = 0b111001;
  244|      7|	    gs.flp_history = 0b1001;
  245|      7|	    gs.pot_size = pot_size;
  246|      7|	    gs.flp_seen = true;
  247|      7|	    gs.trn_seen = true;
  248|       |
  249|      7|	    gs.apply_index(gs.action_to_index(2)); // 0.5x pot
  250|       |
  251|      7|	    gs.print_range_turn(k);
  252|      7|	}
  253|       |
  254|       |
  255|       |
  256|       |	//calculate_exploitability(range, range, board_cards, pot_size);
  257|      1|	calculate_exploitability_fast(range, range, board_cards, pot_size);
  258|       |	// calculate_exploitability_public_tree(range, range, board_cards, pot_size);
  259|       |
  260|       |
  261|       |
  262|      1|	double total_time = 0.0f;
  263|      1|    auto start = std::chrono::high_resolution_clock::now();
  264|      1|    int samples = 100000000;
  265|       |
  266|   100M|    for (int i=0; i<samples; i++) {
  267|   100M|    	std::array<std::array<float, NUM_CARDS>, NUM_CARDS> res = range;
  268|       |
  269|  3.70G|        for (int c1 = 0; c1 < NUM_CARDS; c1++) {
  270|   133G|            for (int c2 = 0; c2 < NUM_CARDS; c2++) {
  271|   129G|                res[c1][c2] += range[c1][c2];
  272|   129G|            }
  273|  3.60G|        }
  274|   100M|    }
  275|       |    
  276|      1|    auto end = std::chrono::high_resolution_clock::now();
  277|      1|    std::chrono::duration<double> elapsed = end - start;
  278|      1|    total_time += elapsed.count();
  279|       |
  280|      1|    std::cout << samples << " iterations of adding 36x36 arrays: "
  281|      1|              << total_time << " seconds. " << samples/total_time << " iterations/second." << "\n";
  282|       |
  283|       |
  284|      1|    total_time = 0.0f;
  285|      1|    start = std::chrono::high_resolution_clock::now();
  286|       |
  287|   100M|    for (int i=0; i<samples; i++) {
  288|   100M|    	std::array<std::array<float, NUM_CARDS>, NUM_CARDS> res;
  289|       |
  290|   100M|        add_2d_arrays_simd(range, range, res);
  291|   100M|    }
  292|       |    
  293|      1|    end = std::chrono::high_resolution_clock::now();
  294|      1|    elapsed = end - start;
  295|      1|    total_time += elapsed.count();
  296|       |
  297|      1|    std::cout << samples << " iterations of SIMD adding 36x36 arrays: "
  298|      1|              << total_time << " seconds. " << samples/total_time << " iterations/second." << "\n";
  299|       |
  300|       |
  301|      1|    return 0;
  302|      1|}

/Users/glen/cfr/shortdecknoluckupdate/src/tree.cpp:
    1|       |#include "tree.h"
    2|       |
    3|      1|Tree::Tree(const GameState& root_state) : root(nullptr) {
    4|      1|    if (root_state.is_chance()) {
    5|      0|        root = std::make_unique<Node>(ChanceNode{});
    6|      1|    } else {
    7|      1|        root = std::make_unique<Node>(DecisionNode(root_state.num_actions()));
    8|      1|    }
    9|      1|    build_tree(root.get(), root_state);
   10|      1|}
   11|       |
   12|  6.17k|Tree::DecisionNode::DecisionNode(int actions) {
   13|   222k|    for (auto& row : strategy_sum) {
   14|  7.99M|        for (auto& cell : row) {
   15|  7.99M|            cell.resize(actions, 0.0f);
   16|  7.99M|        }
   17|   222k|    }
   18|       |
   19|   222k|    for (auto& row : regret_sum) {
   20|  7.99M|        for (auto& cell : row) {
   21|  7.99M|            cell.resize(actions, 0.0f);
   22|  7.99M|        }
   23|   222k|    }
   24|  6.17k|}
   25|       |
   26|      0|std::array<std::array<std::vector<float>, NUM_CARDS>, NUM_CARDS> Tree::get_strategy_tree(const std::vector<int>& history) const {
   27|      0|    Node* node = get_node(history);
   28|      0|    if (node && std::holds_alternative<DecisionNode>(*node)) {
   29|      0|        const auto& decision_node = std::get<DecisionNode>(*node);
   30|      0|        std::array<std::array<std::vector<float>, NUM_CARDS>, NUM_CARDS> strategy;
   31|       |        
   32|      0|        for (int c1=1; c1<=NUM_CARDS; c1++) {
   33|      0|            for (int c2=c1+1; c2<=NUM_CARDS; c2++) {
   34|      0|                const auto& sum = decision_node.strategy_sum[c1 - 1][c2 - 1];
   35|      0|                strategy[c1 - 1][c2 - 1].resize(sum.size());
   36|      0|                float normalizing_sum = 0.0f;
   37|      0|                for (float s : sum) normalizing_sum += s;
   38|      0|                if (normalizing_sum > 1e-8) {
   39|      0|                    for (int a=0; a<sum.size(); a++) {
   40|      0|                        strategy[c1 - 1][c2 - 1][a] = sum[a] / normalizing_sum;
   41|      0|                    }
   42|      0|                } else {
   43|      0|                    float uniform = 1.0f / sum.size();
   44|      0|                    std::fill(strategy[c1 - 1][c2 - 1].begin(), strategy[c1 - 1][c2 - 1].end(), uniform);
   45|      0|                }
   46|      0|            }
   47|      0|        }
   48|      0|        return strategy;
   49|      0|    }
   50|       |    // Return a default strategy if the node doesn't exist or is a chance node
   51|      0|    return std::array<std::array<std::vector<float>, NUM_CARDS>, NUM_CARDS>();
   52|      0|}
   53|       |
   54|  4.50k|void Tree::build_tree(Node* node, const GameState& state) {
   55|  4.50k|    if (state.is_terminal) return;
   56|       |
   57|  1.70k|    if (state.is_chance()) {
   58|     19|        auto& chance_node = node->emplace<ChanceNode>();
   59|    703|        for (int c=1; c<=NUM_CARDS; c++) {
   60|    684|            if (state.has_card(c)) continue;
   61|       |
   62|    608|            GameState new_state = state;
   63|    608|            new_state.deal_card(c);
   64|       |
   65|    608|            if (new_state.is_chance()) {
   66|      0|                chance_node.children[c - 1] = std::make_unique<Node>(ChanceNode{});
   67|    608|            } else {
   68|    608|                chance_node.children[c - 1] = std::make_unique<Node>(DecisionNode(new_state.num_actions()));
   69|    608|            }
   70|       |            
   71|    608|            build_tree(chance_node.children[c - 1].get(), new_state);
   72|    608|        }
   73|  1.68k|    } else {
   74|  1.68k|        int actions = state.num_actions();
   75|  1.68k|        auto& decision_node = node->emplace<DecisionNode>(actions);
   76|  5.58k|        for (int a=0; a<actions; a++) {
   77|  3.89k|            GameState new_state = state;
   78|  3.89k|            new_state.apply_index(a);
   79|       |
   80|  3.89k|            if (new_state.is_chance()) {
   81|     19|                decision_node.children[a] = std::make_unique<Node>(ChanceNode{});
   82|  3.87k|            } else {
   83|  3.87k|                decision_node.children[a] = std::make_unique<Node>(DecisionNode(new_state.num_actions()));
   84|  3.87k|            }
   85|       |
   86|  3.89k|            build_tree(decision_node.children[a].get(), new_state);
   87|  3.89k|        }
   88|  1.68k|    }
   89|  1.70k|}
   90|       |
   91|      0|Tree::Node* Tree::get_node(const std::vector<int>& history) const {
   92|      0|    Node* current = root.get();
   93|      0|    for (int action : history) {
   94|      0|        if (std::holds_alternative<DecisionNode>(*current)) {
   95|      0|            auto& decision_node = std::get<DecisionNode>(*current);
   96|      0|            if (action >= 0 && action < MAX_ACTIONS && decision_node.children[action]) {
   97|      0|                current = decision_node.children[action].get();
   98|      0|            } else {
   99|      0|                return nullptr; // Invalid action
  100|      0|            }
  101|      0|        } else if (std::holds_alternative<ChanceNode>(*current)) {
  102|      0|            auto& chance_node = std::get<ChanceNode>(*current);
  103|      0|            if (action >= 0 && action < NUM_CARDS && chance_node.children[action]) {
  104|      0|                current = chance_node.children[action].get();
  105|      0|            } else {
  106|      0|                return nullptr; // Invalid chance outcome
  107|      0|            }
  108|      0|        } else {
  109|      0|            return nullptr; // Unexpected node type
  110|      0|        }
  111|      0|    }
  112|      0|    return current;
  113|      0|}
  114|       |
  115|      0|int count_nodes(GameState state) {
  116|       |    // Terminal
  117|      0|    if (state.is_terminal) return 0;
  118|       |
  119|      0|    int res = 0;
  120|       |
  121|       |    // Chance
  122|      0|    if (state.is_chance()) {
  123|      0|        for (int c=1; c<=NUM_CARDS; c++) {
  124|      0|            if (state.has_card(c)) continue;
  125|       |
  126|      0|            GameState new_state = state;
  127|      0|            new_state.deal_card(c);
  128|       |
  129|      0|            res += count_nodes(new_state);
  130|      0|        }
  131|      0|        return res;
  132|      0|    }
  133|       |
  134|      0|    int actions = state.num_actions();
  135|       |
  136|       |    // Action
  137|      0|    for (int a=0; a<actions; a++) {
  138|      0|        GameState new_state = state;
  139|      0|        new_state.apply_index(a);
  140|       |
  141|      0|        res += 630 + count_nodes(new_state);
  142|      0|    }
  143|       |
  144|      0|    return res;
  145|      0|}

